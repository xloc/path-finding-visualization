{"version":3,"sources":["theme.ts","Components/NetColorTheme.ts","Components/Grid.tsx","Components/RouteProgressEntry.tsx","Models/Grid.ts","Routers/Router.ts","Models/RouteMap.ts","Components/useRouteMapSelector.tsx","App.tsx","index.tsx"],"names":["theme","createMuiTheme","palette","primary","main","secondary","NetColors","makeRouteMapGrid","routeMap","grid","Array","size","row","fill","map","nouse","i","col","j","isWall","isPin","netID","walls","forEach","nets","net","pins","Grid","routeResult","useState","routeMapGrid","setRouteMapGrid","useEffect","className","cell","GridCell","mapCell","routeResultCell","color","netId","style","backgroundColor","ConnectSucceed","result","id","uuidv4","Box","fontSize","connectionHistory","conn","newConnection","ConnectFailNet","ErrorOutline","failedNet","ConnectFailAll","IntermediateRouteResultType","initializer","this","adjacentCoors","routeConnection","obstacleGrid","sources","targetGrid","progressGrid","inRange","canExpand","expansionList","iExpand","connectedTargetCoors","length","newExpansionList","ni","nj","push","succeed","nExpand","iPrevLayer","segments","filter","connectedPin","routeNet","sourcePin","targets","makeTargetGrid","nTargets","success","ci","cj","connection","makeObstacleGrid","routingNetID","routedConnections","MapCellType","useRouteMapSelector","setRouteMap","infiles","setInfiles","axios","get","then","res","data","mapName","setMapName","input","lines","split","a","parseInt","nCol","nRow","i_line","n_wall","slice","line","n_net","trim","coors","idx","parseRoutingMapString","routeMapSelector","List","filename","ListItem","button","onClick","selected","makeRouteResultGridFromConnections","connections","GridModel","circuitDrawerWidth","useStyles","makeStyles","createStyles","root","display","appBar","width","left","circuitDrawer","flexShrink","circuitDrawerPaper","historyDrawer","historyDrawerPaper","toolbar","mixins","content","flexGrow","background","default","padding","spacing","App","setRouteResult","classes","routeHistory","setRouteHistory","innerResultCallback","prev","currentHistory","setCurrentHistory","undefined","yieldResultCallback","tryToRoute","netRouteSequence","netResult","netSucceed","type","Succeed","otherNetResult","otherNetSucceed","FailNet","FailAll","route","console","log","failNet","error","routingHistory","CssBaseline","ThemeProvider","AppBar","position","Toolbar","Typography","variant","noWrap","Drawer","open","paper","anchor","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.eabe195a.chunk.js","sourcesContent":["import { unstable_createMuiStrictModeTheme as createMuiTheme } from \"@material-ui/core\";\n\nconst theme = createMuiTheme({\n  palette: {\n    primary: {\n      main: \"#203040\",\n    },\n    secondary: {\n      main: \"#abc\",\n    },\n  },\n});\n\nexport default theme;\n","const NetColors = [\n  \"#ff6347\",\n  \"#92da26\", // adff2f\n  \"#4682b4\",\n  \"#F4A460\",\n  \"#dda0dd\",\n\n  \"#6a5acd\",\n  \"#06D6A0\",\n  \"#106b3c\",\n];\n\nexport default NetColors;\n","import { useState, useEffect } from \"react\";\nimport { RouteResult, RouteResultCell } from \"../Models/RouteResult\";\nimport { RouteMap } from \"../Models/RouteMap\";\nimport \"./Grid.css\";\nimport NetColors from \"./NetColorTheme\";\n\nexport class RouteMapCellAttr {\n  isWall = false;\n  isPin = false;\n  netID = -1;\n}\n\nfunction makeRouteMapGrid(routeMap: RouteMap): Array<Array<RouteMapCellAttr>> {\n  const grid = Array(routeMap.size.row)\n    .fill(null)\n    .map((nouse, i) => {\n      return Array(routeMap.size.col)\n        .fill(null)\n        .map((nouse, j) => {\n          return { isWall: false, isPin: false, netID: -1 };\n        });\n    });\n\n  routeMap.walls.forEach(([i, j]) => {\n    grid[i][j].isWall = true;\n  });\n\n  routeMap.nets.forEach((net) => {\n    net.pins.forEach(([i, j]) => {\n      grid[i][j].isPin = true;\n      grid[i][j].netID = net.netID;\n    });\n  });\n\n  return grid;\n}\n\ntype GridProps = {\n  routeMap: RouteMap;\n  routeResult: RouteResult | undefined;\n};\nexport default function Grid({ routeMap, routeResult }: GridProps) {\n  const [routeMapGrid, setRouteMapGrid] = useState(() =>\n    makeRouteMapGrid(routeMap)\n  );\n  useEffect(() => {\n    setRouteMapGrid(makeRouteMapGrid(routeMap));\n  }, [routeMap]);\n\n  return (\n    <div>\n      {routeMapGrid.map((row, i) => {\n        return (\n          <div key={`grid-row ${i}`} className=\"grid-row\">\n            {row.map((cell, j) => {\n              return (\n                <GridCell\n                  key={`grid-cell ${i} ${j}`}\n                  mapCell={cell}\n                  routeResultCell={routeResult?.grid[i][j]}\n                />\n              );\n            })}\n          </div>\n        );\n      })}\n    </div>\n  );\n}\n\ntype GridCellProps = {\n  mapCell: RouteMapCellAttr;\n  routeResultCell: RouteResultCell | undefined;\n};\nexport function GridCell({ mapCell, routeResultCell }: GridCellProps) {\n  let color = \"#ccc\";\n  if (mapCell.isWall) {\n    color = \"black\";\n  } else if (mapCell.isPin) {\n    color = NetColors[mapCell.netID];\n  }\n\n  if (routeResultCell) {\n    if (routeResultCell.netId !== -1) {\n      color = NetColors[routeResultCell.netId];\n    }\n  }\n  return (\n    <div className=\"grid-cell\" style={{ backgroundColor: color }}>\n      <div className={mapCell.isPin ? \"pin\" : \"\"} />\n    </div>\n  );\n}\n","import {\n  CheckCircle as CheckIcon,\n  ErrorOutline as ErrorOutlineIcon,\n  RemoveCircle as BannedIcon,\n} from \"@material-ui/icons\";\nimport { Box } from \"@material-ui/core\";\n\nimport {\n  IntermediateRouteFailAll,\n  IntermediateRouteFailNet,\n  IntermediateRouteSucceed,\n} from \"../Routers/Router\";\nimport NetColors from \"./NetColorTheme\";\nimport \"./RouteProgressEntry.css\";\nimport { v4 as uuidv4 } from \"uuid\";\n\ntype ConnectedSucceedProps = {\n  result: IntermediateRouteSucceed;\n};\nexport function ConnectSucceed({ result }: ConnectedSucceedProps) {\n  const id = uuidv4();\n  return (\n    <div className=\"entry-row\">\n      <Box color=\"success.main\" className=\"icon-alignment\">\n        <CheckIcon fontSize=\"small\" />\n      </Box>\n      <div className=\"history-list\">\n        {result.connectionHistory.map((conn, i) => {\n          return (\n            <div\n              key={`${id} ${i}`}\n              className=\"history-cell\"\n              style={{ backgroundColor: NetColors[conn.netID] }}\n            ></div>\n          );\n        })}\n        <div\n          className=\"history-cell\"\n          style={{ backgroundColor: NetColors[result.newConnection.netID] }}\n        ></div>\n      </div>\n    </div>\n  );\n}\n\ntype ConnectFailNetProps = {\n  result: IntermediateRouteFailNet;\n};\nexport function ConnectFailNet({ result }: ConnectFailNetProps) {\n  const id = uuidv4();\n  return (\n    <div className=\"entry-row\">\n      <Box color=\"error.main\" className=\"icon-alignment\">\n        <ErrorOutlineIcon fontSize=\"small\" />\n      </Box>\n      <div className=\"history-list\">\n        {result.connectionHistory.map((conn, i) => {\n          return (\n            <div\n              key={`${id} ${i}`}\n              className=\"history-cell\"\n              style={{ backgroundColor: NetColors[conn.netID] }}\n            ></div>\n          );\n        })}\n        <div\n          className=\"history-cell\"\n          style={{ backgroundColor: NetColors[result.failedNet.netID] }}\n        ></div>\n      </div>\n    </div>\n  );\n}\n\ntype ConnectFailAllProps = {\n  result: IntermediateRouteFailAll;\n};\nexport function ConnectFailAll({ result }: ConnectFailAllProps) {\n  const id = uuidv4();\n  return (\n    <div className=\"entry-row\">\n      <Box color=\"error.main\" className=\"icon-alignment\">\n        <BannedIcon fontSize=\"small\" />\n      </Box>\n      <div className=\"history-list\">\n        {result.connectionHistory.map((conn, i) => {\n          return (\n            <div\n              key={`${id} ${i}`}\n              className=\"history-cell\"\n              style={{ backgroundColor: NetColors[conn.netID] }}\n            ></div>\n          );\n        })}\n      </div>\n    </div>\n  );\n}\n","export interface GridSize {\n  col: number;\n  row: number;\n}\n\nexport class Grid<T> {\n  grid: Array<Array<T>>;\n  size: GridSize;\n\n  constructor(size: GridSize, initializer: (i: number, j: number) => T) {\n    this.size = size;\n    this.grid = Array(size.row)\n      .fill(null)\n      .map((nouse, i) =>\n        Array(size.col)\n          .fill(null)\n          .map((nouse, j) => initializer(i, j))\n      );\n  }\n}\n","import { Grid, GridSize } from \"../Models/Grid\";\nimport { Coors, Net, RouteMap } from \"../Models/RouteMap\";\n\nexport interface Connection {\n  netID: number;\n  segments: Array<Coors>;\n}\n\ninterface ConnectionRoutingResult {\n  succeed: boolean;\n}\n\ninterface ConnectionRoutingSuccess extends ConnectionRoutingResult {\n  connectedPin: Coors;\n  segments: Array<Coors>;\n}\n\nfunction adjacentCoors(i: number, j: number): Array<Coors> {\n  return [\n    [i + 1, j],\n    [i - 1, j],\n    [i, j + 1],\n    [i, j - 1],\n  ];\n}\n\nexport function routeConnection(\n  obstacleGrid: Grid<boolean>,\n  sources: Array<Coors>,\n  targetGrid: Grid<boolean>\n): ConnectionRoutingResult {\n  const { col, row } = obstacleGrid.size;\n  const progressGrid = new Grid<number>(obstacleGrid.size, (i, j) => -1);\n  const inRange = (i: number, j: number) =>\n    i >= 0 && i < row && j >= 0 && j < col;\n  const canExpand = (i: number, j: number) =>\n    inRange(i, j) && !obstacleGrid.grid[i][j] && progressGrid.grid[i][j] === -1;\n\n  /// expansion\n  let expansionList = sources;\n  let iExpand = 0;\n  let connectedTargetCoors: Coors | null = null;\n  while (expansionList.length > 0) {\n    const newExpansionList = [] as Array<Coors>;\n\n    for (const [i, j] of expansionList) {\n      progressGrid.grid[i][j] = iExpand;\n    }\n    for (const [i, j] of expansionList) {\n      for (const [ni, nj] of adjacentCoors(i, j)) {\n        if (canExpand(ni, nj)) {\n          newExpansionList.push([ni, nj]);\n          progressGrid.grid[ni][nj] = -2;\n          /// whether found one of the targets\n          if (targetGrid.grid[ni][nj]) {\n            connectedTargetCoors = [ni, nj];\n          }\n        }\n      }\n    }\n    /// whether found target\n    if (connectedTargetCoors) {\n      expansionList = [];\n    } else {\n      expansionList = newExpansionList;\n      iExpand++;\n    }\n  }\n\n  if (!connectedTargetCoors) {\n    return { succeed: false };\n  }\n\n  /// backtrack\n  const nExpand = iExpand;\n  let [i, j]: Coors = connectedTargetCoors;\n  let iPrevLayer = nExpand;\n  const segments: Array<Coors> = [];\n  while (true) {\n    /* eslint-disable no-loop-func */\n    [i, j] = adjacentCoors(i, j).filter(([ni, nj]) => {\n      return inRange(ni, nj) && progressGrid.grid[ni][nj] === iPrevLayer;\n    })[0];\n    /* eslint-enable no-loop-func */\n\n    if (progressGrid.grid[i][j] === 0) break;\n    segments.push([i, j]);\n    iPrevLayer--;\n  }\n\n  return {\n    succeed: true,\n    segments,\n    connectedPin: connectedTargetCoors,\n  } as ConnectionRoutingSuccess;\n}\n\nfunction makeTargetGrid(size: GridSize, targets: Array<Coors>) {\n  const grid = new Grid(size, (i, j) => {\n    return false;\n  });\n\n  targets.forEach(([i, j]) => {\n    grid.grid[i][j] = true;\n  });\n\n  return grid;\n}\n\nexport interface NetRoutingResult {\n  succeed: boolean;\n}\nexport interface NetRoutingSuccess extends NetRoutingResult {\n  connection: Connection;\n}\nexport function routeNet(\n  obstacleGrid: Grid<boolean>,\n  net: Net\n): NetRoutingResult {\n  const [sourcePin, ...targets] = net.pins;\n  let sources = [sourcePin];\n  const targetGrid = makeTargetGrid(obstacleGrid.size, targets);\n  let nTargets = targets.length;\n\n  while (nTargets > 0) {\n    const result = routeConnection(obstacleGrid, sources, targetGrid);\n    /// fail to route this net if connection route is fail\n    if (!result.succeed) break;\n    const success = result as ConnectionRoutingSuccess;\n\n    /// update sources and targets\n    nTargets -= 1;\n    sources = [...sources, ...success.segments, success.connectedPin];\n    const [ci, cj] = success.connectedPin; // connected pin coor\n    targetGrid.grid[ci][cj] = false;\n  }\n\n  if (nTargets > 0) {\n    return { succeed: false };\n  } else {\n    return {\n      succeed: true,\n      connection: {\n        netID: net.netID,\n        segments: sources,\n      },\n    } as NetRoutingSuccess;\n  }\n}\n\nexport function makeObstacleGrid(\n  routeMap: RouteMap,\n  routingNetID: number,\n  routedConnections: Array<Connection>\n) {\n  const grid = new Grid(routeMap.size, (i, j) => {\n    return false;\n  });\n\n  /// walls are obstacles\n  routeMap.walls.forEach(([i, j]) => {\n    grid.grid[i][j] = true;\n  });\n\n  /// net pins that are not in the routing net are obstacles\n  routeMap.nets\n    .filter((net) => net.netID !== routingNetID)\n    .forEach((net) => {\n      net.pins.forEach(([i, j]) => {\n        grid.grid[i][j] = true;\n      });\n    });\n\n  /// routed connection are obstacles\n  routedConnections.forEach((connection) => {\n    connection.segments.forEach(([i, j]) => {\n      grid.grid[i][j] = true;\n    });\n  });\n\n  return grid;\n}\n\nexport interface MapRouteResult {\n  succeed: boolean;\n}\n\nexport interface MapRouteSuccess extends MapRouteResult {\n  netRouteSequence: Array<Net>;\n  connections: Array<Connection>;\n}\n\nexport interface RouteQueueItem {\n  priority: number;\n  net: Net;\n}\n\nexport interface IntermediateRouteSucceed extends IntermediateRouteResult {\n  connectionHistory: Array<Connection>;\n  newConnection: Connection;\n}\n\nexport interface IntermediateRouteFailNet extends IntermediateRouteResult {\n  connectionHistory: Array<Connection>;\n  failedNet: Net;\n}\n\nexport interface IntermediateRouteFailAll extends IntermediateRouteResult {\n  connectionHistory: Array<Connection>;\n}\n\nexport enum IntermediateRouteResultType {\n  Succeed = 0,\n  FailNet,\n  FailAll,\n}\n\nexport interface IntermediateRouteResult {\n  type: IntermediateRouteResultType;\n}\n\nexport function route(\n  routeMap: RouteMap,\n  yieldResultCallback: (arg0: IntermediateRouteResult) => void\n): MapRouteResult {\n  function tryToRoute(\n    nets: Array<Net>,\n    routedConnections: Array<Connection>\n  ): MapRouteResult {\n    if (nets.length === 0) {\n      return {\n        succeed: true,\n        netRouteSequence: [],\n        connections: [],\n      } as MapRouteSuccess;\n    }\n\n    for (let i = 0; i < nets.length; i++) {\n      const net = nets[i];\n\n      /// try to route the net\n      const obstacleGrid = makeObstacleGrid(routeMap, i, routedConnections);\n      const netResult = routeNet(obstacleGrid, net);\n      if (!netResult.succeed) {\n        yieldResultCallback({\n          type: IntermediateRouteResultType.FailNet,\n          connectionHistory: routedConnections,\n          failedNet: net,\n        } as IntermediateRouteFailNet);\n        continue;\n      }\n      const netSucceed = netResult as NetRoutingSuccess;\n      yieldResultCallback({\n        type: IntermediateRouteResultType.Succeed,\n        connectionHistory: routedConnections,\n        newConnection: netSucceed.connection,\n      } as IntermediateRouteSucceed);\n\n      /// if this net can be connected => try route other nets\n      const otherNets = [...nets.slice(0, i), ...nets.slice(i + 1)];\n      const otherNetResult = tryToRoute(otherNets, [\n        ...routedConnections,\n        netSucceed.connection,\n      ]);\n      if (otherNetResult.succeed) {\n        const otherNetSucceed = otherNetResult as MapRouteSuccess;\n        return {\n          succeed: true,\n          netRouteSequence: [net, ...otherNetSucceed.netRouteSequence],\n          connections: [netSucceed.connection, ...otherNetSucceed.connections],\n        } as MapRouteSuccess;\n      }\n    }\n\n    yieldResultCallback({\n      type: IntermediateRouteResultType.FailAll,\n      connectionHistory: routedConnections,\n    } as IntermediateRouteFailAll);\n    return { succeed: false };\n  }\n\n  return tryToRoute(routeMap.nets, []);\n}\n","import { GridSize } from \"./Grid\";\n\nexport enum MapCellType {\n  void = 0,\n  wall,\n  pin,\n}\n\nexport type Coors = [number, number];\nexport interface Net {\n  netID: number;\n  pins: Array<Coors>;\n}\n\nexport interface RouteMap {\n  size: GridSize;\n  walls: Array<Coors>;\n  nets: Array<Net>;\n}\n\nexport function parseRoutingMapString(input: string): RouteMap {\n  const lines = input.split(\"\\n\");\n  const [nCol, nRow] = lines[0].split(\" \").map((a) => parseInt(a));\n  let i_line = 1;\n\n  /// parse obstacles\n  const n_wall = parseInt(lines[i_line++]);\n  const walls = lines.slice(i_line, i_line + n_wall).map((line) => {\n    const [j, i] = line.split(\" \").map((a) => parseInt(a));\n    return [i, j] as Coors;\n  });\n  i_line += n_wall;\n\n  /// parse nets\n  const nets: Array<Net> = [];\n  const n_net = parseInt(lines[i_line++]);\n  lines.slice(i_line, i_line + n_net).forEach((line, netID) => {\n    /// parse pins\n    const [, ...coors] = line\n      .trim()\n      .split(\" \")\n      .map((a) => parseInt(a));\n    const net: Net = { netID: netID, pins: [] };\n    for (let idx = 0; idx < coors.length; idx += 2) {\n      const j = coors[idx],\n        i = coors[idx + 1];\n      net.pins.push([i, j]);\n    }\n    nets.push(net);\n  });\n\n  return {\n    size: { col: nCol, row: nRow },\n    walls: walls,\n    nets: nets,\n  };\n}\n","import { List, ListItem } from \"@material-ui/core\";\nimport axios from \"axios\";\nimport { useEffect, useState } from \"react\";\nimport { parseRoutingMapString, RouteMap } from \"../Models/RouteMap\";\n\nexport function useRouteMapSelector(setRouteMap: (arg0: RouteMap) => void) {\n  const [infiles, setInfiles] = useState<Array<string>>();\n  useEffect(() => {\n    axios.get(\"benchmarks/infiles.json\").then((res) => {\n      setInfiles(res.data);\n    });\n    return () => {};\n  }, []);\n\n  const [mapName, setMapName] = useState(\"impossible.infile\");\n  useEffect(() => {\n    if (mapName === \"\") return;\n    axios.get<string>(`benchmarks/${mapName}`).then((res) => {\n      setRouteMap(parseRoutingMapString(res.data));\n    });\n\n    /// TODO clean up\n  }, [mapName, setRouteMap]);\n\n  const routeMapSelector = (\n    <List>\n      {infiles?.map((filename) => (\n        <ListItem\n          button\n          key={filename}\n          onClick={() => setMapName(filename)}\n          selected={filename === mapName}\n        >\n          {filename.split(\".\")[0]}\n        </ListItem>\n      ))}\n    </List>\n  );\n\n  return { routeMapSelector, mapName };\n}\n","import React, { useEffect, useState } from \"react\";\nimport {\n  AppBar,\n  createStyles,\n  CssBaseline,\n  Drawer,\n  List,\n  ListItem,\n  makeStyles,\n  Theme,\n  ThemeProvider,\n  Toolbar,\n  Typography,\n} from \"@material-ui/core\";\n\n/// User Component Imports\nimport theme from \"./theme\";\nimport \"./App.css\";\nimport Grid from \"./Components/Grid\";\nimport {\n  ConnectSucceed,\n  ConnectFailAll,\n  ConnectFailNet,\n} from \"./Components/RouteProgressEntry\";\n\n/// User Model Imports\nimport { Grid as GridModel, GridSize } from \"./Models/Grid\";\nimport { RouteMap } from \"./Models/RouteMap\";\nimport {\n  route,\n  MapRouteSuccess,\n  IntermediateRouteResultType,\n  IntermediateRouteResult,\n  IntermediateRouteSucceed,\n  IntermediateRouteFailNet,\n  IntermediateRouteFailAll,\n  Connection,\n} from \"./Routers/Router\";\nimport { RouteResult, RouteResultCell } from \"./Models/RouteResult\";\nimport { useRouteMapSelector } from \"./Components/useRouteMapSelector\";\n\nfunction makeRouteResultGridFromConnections(\n  size: GridSize,\n  connections: Array<Connection>\n) {\n  const grid = new GridModel<RouteResultCell>(size, (i, j) => ({\n    netId: -1,\n  }));\n  connections.forEach((conn) => {\n    conn.segments.forEach(([i, j]) => {\n      grid.grid[i][j].netId = conn.netID;\n    });\n  });\n  return grid;\n}\n\nconst circuitDrawerWidth = 150;\nconst historyDrawerWidth = 150;\nconst useStyles = makeStyles((theme: Theme) =>\n  createStyles({\n    root: {\n      display: \"flex\",\n    },\n    appBar: {\n      width: `calc(100% - ${circuitDrawerWidth}px - ${historyDrawerWidth}px)`,\n      left: circuitDrawerWidth,\n    },\n    circuitDrawer: {\n      width: circuitDrawerWidth,\n      flexShrink: 0,\n    },\n    circuitDrawerPaper: {\n      width: circuitDrawerWidth,\n    },\n    historyDrawer: {\n      width: historyDrawerWidth,\n    },\n    historyDrawerPaper: {\n      width: historyDrawerWidth,\n      flexShrink: 0,\n    },\n    // necessary for content to be below app bar\n    toolbar: theme.mixins.toolbar,\n    content: {\n      flexGrow: 1,\n      backgroundColor: theme.palette.background.default,\n      padding: theme.spacing(3),\n    },\n  })\n);\n\nfunction App() {\n  const [routeResult, setRouteResult] = useState<RouteResult>();\n  const [routeMap, setRouteMap] = useState<RouteMap>();\n  const classes = useStyles();\n\n  const { routeMapSelector, mapName } = useRouteMapSelector(setRouteMap);\n\n  const [routeHistory, setRouteHistory] = useState(\n    [] as Array<IntermediateRouteResult>\n  );\n\n  const innerResultCallback = (result: IntermediateRouteResult) => {\n    setRouteHistory((prev) => {\n      if (prev.length > 100) return prev;\n      return [...prev, result];\n    });\n  };\n\n  const [\n    currentHistory,\n    setCurrentHistory,\n  ] = useState<IntermediateRouteResult>();\n\n  useEffect(() => {\n    if (!routeMap) return;\n\n    setCurrentHistory(undefined);\n    setRouteHistory([]);\n    const routeResult = route(routeMap, innerResultCallback);\n\n    if (!routeResult.succeed) {\n      setRouteResult(undefined);\n      return;\n    }\n    const succeed = routeResult as MapRouteSuccess;\n    console.log(succeed);\n\n    const grid = makeRouteResultGridFromConnections(\n      routeMap.size,\n      succeed.connections\n    );\n    setRouteResult(grid);\n  }, [routeMap]);\n\n  useEffect(() => {\n    if (!routeMap) return;\n    if (!currentHistory) return;\n\n    switch (currentHistory.type) {\n      case IntermediateRouteResultType.Succeed:\n        {\n          const succeed = currentHistory as IntermediateRouteSucceed;\n          const grid = makeRouteResultGridFromConnections(routeMap.size, [\n            ...succeed.connectionHistory,\n            succeed.newConnection,\n          ]);\n          setRouteResult(grid);\n        }\n        break;\n      case IntermediateRouteResultType.FailNet:\n        {\n          const failNet = currentHistory as IntermediateRouteFailNet;\n          const grid = makeRouteResultGridFromConnections(\n            routeMap.size,\n            failNet.connectionHistory\n          );\n          setRouteResult(grid);\n        }\n        break;\n      case IntermediateRouteResultType.FailAll:\n        break;\n      default:\n        console.error(\"should not reach here\");\n    }\n    /// TODO: figure out why adding routeMap leads to problem\n  }, [currentHistory]); // eslint-disable-line react-hooks/exhaustive-deps\n\n  const routingHistory = (\n    <List>\n      {routeHistory.map((result, i) => (\n        <ListItem\n          button\n          key={`history ${i}`}\n          onClick={() => setCurrentHistory(result)}\n          selected={result === currentHistory}\n        >\n          {(() => {\n            switch (result.type) {\n              case IntermediateRouteResultType.Succeed:\n                return (\n                  <ConnectSucceed\n                    result={result as IntermediateRouteSucceed}\n                  ></ConnectSucceed>\n                );\n              case IntermediateRouteResultType.FailNet:\n                return (\n                  <ConnectFailNet\n                    result={result as IntermediateRouteFailNet}\n                  ></ConnectFailNet>\n                );\n              case IntermediateRouteResultType.FailAll:\n                return (\n                  <ConnectFailAll\n                    result={result as IntermediateRouteFailAll}\n                  ></ConnectFailAll>\n                );\n              default:\n                return \"0\";\n            }\n          })()}\n        </ListItem>\n      ))}\n    </List>\n  );\n\n  return (\n    <div className={classes.root}>\n      <CssBaseline />\n      <ThemeProvider theme={theme}>\n        <AppBar position=\"fixed\" className={classes.appBar}>\n          <Toolbar>\n            {\" \"}\n            <Typography variant=\"h6\" noWrap>\n              {mapName}\n            </Typography>\n          </Toolbar>\n        </AppBar>\n        <Drawer\n          open={true}\n          variant=\"permanent\"\n          className={classes.circuitDrawer}\n          classes={{ paper: classes.circuitDrawerPaper }}\n        >\n          {routeMapSelector}\n        </Drawer>\n        <main className={classes.content}>\n          <div className={classes.toolbar} />\n          {routeMap ? (\n            <Grid routeMap={routeMap} routeResult={routeResult} />\n          ) : (\n            <></>\n          )}\n        </main>\n        <Drawer\n          open={true}\n          variant=\"permanent\"\n          className={classes.historyDrawer}\n          classes={{ paper: classes.historyDrawerPaper }}\n          anchor=\"right\"\n        >\n          {routingHistory}\n        </Drawer>\n      </ThemeProvider>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}