{"version":3,"sources":["theme.ts","Components/Grid.tsx","Models/RouteMap.ts","Models/Grid.ts","Routers/Router.ts","App.tsx","index.tsx"],"names":["theme","createMuiTheme","palette","primary","main","secondary","makeRouteMapGrid","routeMap","grid","Array","size","row","fill","map","nouse","i","col","j","isWall","isPin","netID","walls","forEach","nets","net","pins","Grid","routeResult","useState","routeMapGrid","setRouteMapGrid","useEffect","className","cell","GridCell","mapCell","routeResultCell","netColors","color","netId","style","backgroundColor","MapCellType","initializer","this","adjacentCoors","routeConnection","obstacleGrid","sources","targetGrid","progressGrid","inRange","canExpand","expansionList","iExpand","connectedTargetCoors","length","newExpansionList","ni","nj","push","succeed","nExpand","iPrevLayer","segments","filter","connectedPin","routeNet","sourcePin","targets","makeTargetGrid","nTargets","result","success","ci","cj","connection","makeObstacleGrid","routingNetID","routedConnections","drawerWidth","useStyles","makeStyles","createStyles","root","display","appBar","width","marginLeft","drawer","flexShrink","drawerPaper","toolbar","mixins","content","flexGrow","background","default","padding","spacing","App","setRouteResult","setRouteMap","classes","tryToRoute","netRouteSequence","connections","netResult","netSucceed","otherNetResult","slice","otherNetSucceed","route","console","log","GridModel","conn","undefined","infiles","setInfiles","axios","get","then","res","data","mapName","setMapName","input","lines","split","a","parseInt","nCol","nRow","i_line","n_wall","line","n_net","trim","coors","idx","parseRoutingMapString","routingMapList","List","filename","ListItem","button","onClick","selected","CssBaseline","ThemeProvider","AppBar","position","Toolbar","Typography","variant","noWrap","Drawer","open","paper","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.d7b56514.chunk.js","sourcesContent":["import { unstable_createMuiStrictModeTheme as createMuiTheme } from \"@material-ui/core\";\n\nconst theme = createMuiTheme({\n  palette: {\n    primary: {\n      main: \"#203040\",\n    },\n    secondary: {\n      main: \"#abc\",\n    },\n  },\n});\n\nexport default theme;\n","import { useState, useEffect } from \"react\";\nimport { RouteResult, RouteResultCell } from \"../App\";\nimport { RouteMap } from \"../Models/RouteMap\";\nimport \"./Grid.css\";\n\nexport class RouteMapCellAttr {\n  isWall = false;\n  isPin = false;\n  netID = -1;\n}\n\nfunction makeRouteMapGrid(routeMap: RouteMap): Array<Array<RouteMapCellAttr>> {\n  const grid = Array(routeMap.size.row)\n    .fill(null)\n    .map((nouse, i) => {\n      return Array(routeMap.size.col)\n        .fill(null)\n        .map((nouse, j) => {\n          return { isWall: false, isPin: false, netID: -1 };\n        });\n    });\n\n  routeMap.walls.forEach(([i, j]) => {\n    grid[i][j].isWall = true;\n  });\n\n  routeMap.nets.forEach((net) => {\n    net.pins.forEach(([i, j]) => {\n      grid[i][j].isPin = true;\n      grid[i][j].netID = net.netID;\n    });\n  });\n\n  return grid;\n}\n\ntype GridProps = {\n  routeMap: RouteMap;\n  routeResult: RouteResult | undefined;\n};\nexport default function Grid({ routeMap, routeResult }: GridProps) {\n  const [routeMapGrid, setRouteMapGrid] = useState(() =>\n    makeRouteMapGrid(routeMap)\n  );\n  useEffect(() => {\n    setRouteMapGrid(makeRouteMapGrid(routeMap));\n  }, [routeMap]);\n\n  return (\n    <div>\n      {routeMapGrid.map((row, i) => {\n        return (\n          <div key={`grid-row ${i}`} className=\"grid-row\">\n            {row.map((cell, j) => {\n              return (\n                <GridCell\n                  key={`grid-cell ${i} ${j}`}\n                  mapCell={cell}\n                  routeResultCell={routeResult?.grid[i][j]}\n                />\n              );\n            })}\n          </div>\n        );\n      })}\n    </div>\n  );\n}\n\nconst netColors = [\n  \"#ff6347\",\n  \"#adff2f\",\n  \"#4682b4\",\n  \"#F4A460\",\n  \"#dda0dd\",\n\n  \"#6a5acd\",\n  \"#00ff7f\",\n];\n\ntype GridCellProps = {\n  mapCell: RouteMapCellAttr;\n  routeResultCell: RouteResultCell | undefined;\n};\nexport function GridCell({ mapCell, routeResultCell }: GridCellProps) {\n  let color = \"#ccc\";\n  if (mapCell.isWall) {\n    color = \"black\";\n  } else if (mapCell.isPin) {\n    color = netColors[mapCell.netID];\n  }\n\n  if (routeResultCell) {\n    if (routeResultCell.netId !== -1) {\n      color = netColors[routeResultCell.netId];\n    }\n  }\n  return <div className=\"grid-cell\" style={{ backgroundColor: color }}></div>;\n}\n","import { GridSize } from \"./Grid\";\n\nexport enum MapCellType {\n  void = 0,\n  wall,\n  pin,\n}\n\nexport type Coors = [number, number];\nexport interface Net {\n  netID: number;\n  pins: Array<Coors>;\n}\n\nexport interface RouteMap {\n  size: GridSize;\n  walls: Array<Coors>;\n  nets: Array<Net>;\n}\n\nexport function parseRoutingMapString(input: string): RouteMap {\n  const lines = input.split(\"\\n\");\n  const [nCol, nRow] = lines[0].split(\" \").map((a) => parseInt(a));\n  let i_line = 1;\n\n  /// parse obstacles\n  const n_wall = parseInt(lines[i_line++]);\n  const walls = lines.slice(i_line, i_line + n_wall).map((line) => {\n    const [j, i] = line.split(\" \").map((a) => parseInt(a));\n    return [i, j] as Coors;\n  });\n  i_line += n_wall;\n\n  /// parse nets\n  const nets: Array<Net> = [];\n  const n_net = parseInt(lines[i_line++]);\n  lines.slice(i_line, i_line + n_net).forEach((line, netID) => {\n    /// parse pins\n    const [, ...coors] = line\n      .trim()\n      .split(\" \")\n      .map((a) => parseInt(a));\n    const net: Net = { netID: netID, pins: [] };\n    for (let idx = 0; idx < coors.length; idx += 2) {\n      const j = coors[idx],\n        i = coors[idx + 1];\n      net.pins.push([i, j]);\n    }\n    nets.push(net);\n  });\n\n  return {\n    size: { col: nCol, row: nRow },\n    walls: walls,\n    nets: nets,\n  };\n}\n","export interface GridSize {\n  col: number;\n  row: number;\n}\n\nexport class Grid<T> {\n  grid: Array<Array<T>>;\n  size: GridSize;\n\n  constructor(size: GridSize, initializer: (i: number, j: number) => T) {\n    this.size = size;\n    this.grid = Array(size.row)\n      .fill(null)\n      .map((nouse, i) =>\n        Array(size.col)\n          .fill(null)\n          .map((nouse, j) => initializer(i, j))\n      );\n  }\n}\n","import { Grid, GridSize } from \"../Models/Grid\";\nimport { Coors, Net, RouteMap } from \"../Models/RouteMap\";\n\nexport interface Connection {\n  netID: number;\n  segments: Array<Coors>;\n}\n\ninterface ConnectionRoutingResult {\n  succeed: boolean;\n}\n\ninterface ConnectionRoutingSuccess extends ConnectionRoutingResult {\n  connectedPin: Coors;\n  segments: Array<Coors>;\n}\n\nfunction adjacentCoors(i: number, j: number): Array<Coors> {\n  return [\n    [i + 1, j],\n    [i - 1, j],\n    [i, j + 1],\n    [i, j - 1],\n  ];\n}\n\nexport function routeConnection(\n  obstacleGrid: Grid<boolean>,\n  sources: Array<Coors>,\n  targetGrid: Grid<boolean>\n): ConnectionRoutingResult {\n  const { col, row } = obstacleGrid.size;\n  const progressGrid = new Grid<number>(obstacleGrid.size, (i, j) => -1);\n  const inRange = (i: number, j: number) =>\n    i >= 0 && i < row && j >= 0 && j < col;\n  const canExpand = (i: number, j: number) =>\n    inRange(i, j) && !obstacleGrid.grid[i][j] && progressGrid.grid[i][j] === -1;\n\n  /// expansion\n  let expansionList = sources;\n  let iExpand = 0;\n  let connectedTargetCoors: Coors | null = null;\n  while (expansionList.length > 0) {\n    const newExpansionList = [] as Array<Coors>;\n\n    for (const [i, j] of expansionList) {\n      progressGrid.grid[i][j] = iExpand;\n    }\n    for (const [i, j] of expansionList) {\n      for (const [ni, nj] of adjacentCoors(i, j)) {\n        if (canExpand(ni, nj)) {\n          newExpansionList.push([ni, nj]);\n          progressGrid.grid[ni][nj] = -2;\n          /// whether found one of the targets\n          if (targetGrid.grid[ni][nj]) {\n            connectedTargetCoors = [ni, nj];\n          }\n        }\n      }\n    }\n    /// whether found target\n    if (connectedTargetCoors) {\n      expansionList = [];\n    } else {\n      expansionList = newExpansionList;\n      iExpand++;\n    }\n  }\n\n  if (!connectedTargetCoors) {\n    return { succeed: false };\n  }\n\n  /// backtrack\n  const nExpand = iExpand;\n  let [i, j]: Coors = connectedTargetCoors;\n  let iPrevLayer = nExpand;\n  const segments: Array<Coors> = [];\n  while (true) {\n    /* eslint-disable no-loop-func */\n    [i, j] = adjacentCoors(i, j).filter(([ni, nj]) => {\n      return inRange(ni, nj) && progressGrid.grid[ni][nj] === iPrevLayer;\n    })[0];\n    /* eslint-enable no-loop-func */\n\n    if (progressGrid.grid[i][j] === 0) break;\n    segments.push([i, j]);\n    iPrevLayer--;\n  }\n\n  return {\n    succeed: true,\n    segments,\n    connectedPin: connectedTargetCoors,\n  } as ConnectionRoutingSuccess;\n}\n\nfunction makeTargetGrid(size: GridSize, targets: Array<Coors>) {\n  const grid = new Grid(size, (i, j) => {\n    return false;\n  });\n\n  targets.forEach(([i, j]) => {\n    grid.grid[i][j] = true;\n  });\n\n  return grid;\n}\n\nexport interface NetRoutingResult {\n  succeed: boolean;\n}\nexport interface NetRoutingSuccess extends NetRoutingResult {\n  connection: Connection;\n}\nexport function routeNet(\n  obstacleGrid: Grid<boolean>,\n  net: Net\n): NetRoutingResult {\n  const [sourcePin, ...targets] = net.pins;\n  let sources = [sourcePin];\n  const targetGrid = makeTargetGrid(obstacleGrid.size, targets);\n  let nTargets = targets.length;\n\n  while (nTargets > 0) {\n    const result = routeConnection(obstacleGrid, sources, targetGrid);\n    /// fail to route this net if connection route is fail\n    if (!result.succeed) break;\n    const success = result as ConnectionRoutingSuccess;\n\n    /// update sources and targets\n    nTargets -= 1;\n    sources = [...sources, ...success.segments, success.connectedPin];\n    const [ci, cj] = success.connectedPin; // connected pin coor\n    targetGrid.grid[ci][cj] = false;\n  }\n\n  if (nTargets > 0) {\n    return { succeed: false };\n  } else {\n    return {\n      succeed: true,\n      connection: {\n        netID: net.netID,\n        segments: sources,\n      },\n    } as NetRoutingSuccess;\n  }\n}\n\nexport function makeObstacleGrid(\n  routeMap: RouteMap,\n  routingNetID: number,\n  routedConnections: Array<Connection>\n) {\n  const grid = new Grid(routeMap.size, (i, j) => {\n    return false;\n  });\n\n  /// walls are obstacles\n  routeMap.walls.forEach(([i, j]) => {\n    grid.grid[i][j] = true;\n  });\n\n  /// net pins that are not in the routing net are obstacles\n  routeMap.nets\n    .filter((net) => net.netID !== routingNetID)\n    .forEach((net) => {\n      net.pins.forEach(([i, j]) => {\n        grid.grid[i][j] = true;\n      });\n    });\n\n  /// routed connection are obstacles\n  routedConnections.forEach((connection) => {\n    connection.segments.forEach(([i, j]) => {\n      grid.grid[i][j] = true;\n    });\n  });\n\n  return grid;\n}\n\nexport interface MapRouteResult {\n  succeed: boolean;\n}\n\nexport interface MapRouteSuccess extends MapRouteResult {\n  netRouteSequence: Array<Net>;\n  connections: Array<Connection>;\n}\n\nexport interface RouteQueueItem {\n  priority: number;\n  net: Net;\n}\nexport function route(routeMap: RouteMap): MapRouteResult {\n  function tryToRoute(\n    nets: Array<Net>,\n    routedConnections: Array<Connection>\n  ): MapRouteResult {\n    if (nets.length === 0) {\n      return {\n        succeed: true,\n        netRouteSequence: [],\n        connections: [],\n      } as MapRouteSuccess;\n    }\n\n    for (let i = 0; i < nets.length; i++) {\n      const net = nets[i];\n\n      /// try to route the net\n      const obstacleGrid = makeObstacleGrid(routeMap, i, routedConnections);\n      const netResult = routeNet(obstacleGrid, net);\n      if (!netResult.succeed) return { succeed: false };\n      const netSucceed = netResult as NetRoutingSuccess;\n\n      /// if this net can be connected => try route other nets\n      const otherNets = [...nets.slice(0, i), ...nets.slice(i + 1)];\n      const otherNetResult = tryToRoute(otherNets, [\n        ...routedConnections,\n        netSucceed.connection,\n      ]);\n      if (otherNetResult.succeed) {\n        const otherNetSucceed = otherNetResult as MapRouteSuccess;\n        return {\n          succeed: true,\n          netRouteSequence: [net, ...otherNetSucceed.netRouteSequence],\n          connections: [netSucceed.connection, ...otherNetSucceed.connections],\n        } as MapRouteSuccess;\n      }\n    }\n\n    return { succeed: false };\n  }\n\n  return tryToRoute(routeMap.nets, []);\n}\n","import React, { useEffect, useState } from \"react\";\nimport axios from \"axios\";\nimport {\n  AppBar,\n  Container,\n  createStyles,\n  CssBaseline,\n  Divider,\n  Drawer,\n  List,\n  ListItem,\n  makeStyles,\n  MenuItem,\n  Select,\n  Theme,\n  ThemeProvider,\n  Toolbar,\n  Typography,\n} from \"@material-ui/core\";\n\nimport theme from \"./theme\";\nimport \"./App.css\";\nimport Grid from \"./Components/Grid\";\nimport { parseRoutingMapString, RouteMap } from \"./Models/RouteMap\";\nimport { route, MapRouteSuccess } from \"./Routers/Router\";\nimport { Grid as GridModel } from \"./Models/Grid\";\n\nexport interface RouteResultCell {\n  netId: number;\n}\nexport type RouteResult = GridModel<RouteResultCell>;\n\nconst drawerWidth = 150;\n\nconst useStyles = makeStyles((theme: Theme) =>\n  createStyles({\n    root: {\n      display: \"flex\",\n    },\n    appBar: {\n      width: `calc(100% - ${drawerWidth}px)`,\n      marginLeft: drawerWidth,\n    },\n    drawer: {\n      width: drawerWidth,\n      flexShrink: 0,\n    },\n    drawerPaper: {\n      width: drawerWidth,\n    },\n    // necessary for content to be below app bar\n    toolbar: theme.mixins.toolbar,\n    content: {\n      flexGrow: 1,\n      backgroundColor: theme.palette.background.default,\n      padding: theme.spacing(3),\n    },\n  })\n);\n\nfunction App() {\n  const [routeResult, setRouteResult] = useState<RouteResult>();\n  const [routeMap, setRouteMap] = useState<RouteMap>();\n  const classes = useStyles();\n\n  useEffect(() => {\n    if (!routeMap) return;\n\n    const routeResult = route(routeMap);\n\n    if (!routeResult.succeed) {\n      setRouteResult(undefined);\n      return;\n    }\n    const succeed = routeResult as MapRouteSuccess;\n    console.log(succeed);\n\n    const grid = new GridModel<RouteResultCell>(routeMap.size, (i, j) => ({\n      netId: -1,\n    }));\n    succeed.connections.forEach((conn) => {\n      conn.segments.forEach(([i, j]) => {\n        grid.grid[i][j].netId = conn.netID;\n      });\n    });\n    setRouteResult(grid);\n  }, [routeMap]);\n\n  function next() {\n    // const grid = new GridModel<RouteResultCell>(routeMap.size, (i, j) => ({\n    //   netId: -1,\n    // }));\n    // grid.grid[0][0].netId = 0;\n    // setRouteResult(grid);\n  }\n\n  const [infiles, setInfiles] = useState<Array<string>>();\n  useEffect(() => {\n    axios.get(\"benchmarks/infiles.json\").then((res) => {\n      setInfiles(res.data);\n    });\n    return () => {};\n  }, []);\n\n  const [mapName, setMapName] = useState(\"impossible.infile\");\n  useEffect(() => {\n    if (mapName === \"\") return;\n    axios.get<string>(`benchmarks/${mapName}`).then((res) => {\n      setRouteMap(parseRoutingMapString(res.data));\n    });\n\n    /// TODO clean up\n  }, [mapName]);\n\n  const routingMapList = (\n    <List>\n      {infiles?.map((filename) => (\n        <ListItem\n          button\n          key={filename}\n          onClick={() => setMapName(filename)}\n          selected={filename === mapName}\n        >\n          {filename.split(\".\")[0]}\n        </ListItem>\n      ))}\n    </List>\n  );\n\n  return (\n    <div className={classes.root}>\n      <CssBaseline />\n      <ThemeProvider theme={theme}>\n        <AppBar position=\"fixed\" className={classes.appBar}>\n          <Toolbar>\n            {\" \"}\n            <Typography variant=\"h6\" noWrap>\n              {mapName}\n            </Typography>\n          </Toolbar>\n        </AppBar>\n        <Drawer\n          open={true}\n          variant=\"permanent\"\n          className={classes.drawer}\n          classes={{\n            paper: classes.drawerPaper,\n          }}\n        >\n          {routingMapList}\n        </Drawer>\n        <main className={classes.content}>\n          <div className={classes.toolbar} />\n          {routeMap ? (\n            <Grid routeMap={routeMap} routeResult={routeResult} />\n          ) : (\n            <></>\n          )}\n        </main>\n      </ThemeProvider>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}