{"version":3,"sources":["theme.ts","Components/NetColorTheme.ts","Components/Grid.tsx","Components/RouteProgressEntry.tsx","Routers/RouteResults.ts","Models/Grid.ts","Routers/utils.ts","Routers/Router.ts","Models/RouteMap.ts","Components/useRouteMapSelector.tsx","Routers/aStarRoute.ts","App.tsx","index.tsx"],"names":["theme","createMuiTheme","palette","primary","main","secondary","NetColors","makeRouteMapGrid","routeMap","grid","Array","size","row","fill","map","nouse","i","col","j","isWall","isPin","netID","walls","forEach","nets","net","pins","Grid","circuit","segments","progress","useState","routeMapGrid","setRouteMapGrid","useEffect","className","cell","GridCell","mapCell","segment","color","netId","shadow","visited","style","backgroundColor","ConnectSucceed","result","id","uuidv4","Box","fontSize","connectionHistory","conn","newConnection","ConnectFailNet","ErrorOutline","failedNet","ConnectFailAll","IntermediateRouteResultType","initializer","this","fn","val","adjacentCoors","makeObstacleGrid","routedConnections","routingNetID","filter","connection","makeRouteResultGridFromConnections","connections","ExpandProgress","active","BacktrackProgress","segHistory","newSegment","buildExpandProgress","progressGrid","copyNumber","ConnectionRouteHistory","sources","dijkstraRoute","obstacleGrid","targetGrid","historyRecord","inRange","canExpand","expansionList","iExpand","connectedTargetCoors","length","newExpansionList","ni","nj","push","type","succeed","nExpand","iPrevLayer","connectedPin","NetRouteHistory","segmentGrid","connectionHistories","routeNet","connectionRouter","sourcePin","targets","makeTargetGrid","nTargets","getConnectionHistory","ch","h","success","ci","cj","CircuitRouteHistory","netHistories","routeCircuitUntilFail","netSequence","wireGrid","netHistory","netResult","MapCellType","useRouteMapSelector","setRouteMap","infiles","setInfiles","axios","get","then","res","data","mapName","setMapName","input","lines","split","a","parseInt","nCol","nRow","i_line","n_wall","slice","line","n_net","trim","coors","idx","parseRoutingMapString","routeMapSelector","List","filename","ListItem","button","onClick","selected","coorsDist","b","QueueItem","dist","closest","others","minDist","c","d","queue","compareItem","popAllEqualDist","coorsList","peek","dequeue","aStarRoute","expandFromGrid","list","isTarget","convertTargetGridToList","isStart","PriorityQueue","comparator","s","buildQueue","clear","error","circuitDrawerWidth","useStyles","makeStyles","createStyles","root","display","appBar","width","left","circuitDrawer","flexShrink","circuitDrawerPaper","historyDrawer","historyDrawerPaper","toolbar","mixins","content","flexGrow","background","default","buildRouteProgress","currentProgress","netH","connH","p","App","routeResult","setRouteResult","setProgressGrid","routerName","setRouterName","classes","routeHistories","setRouteHistories","maxNetConnections","innerResultCallback","prev","Succeed","nConnection","currentHistory","setCurrentHistory","undefined","yieldResultCallback","tryToRoute","netRouteSequence","netSucceed","otherNetResult","otherNetSucceed","FailNet","FailAll","routeCircuit","console","log","failNet","setCurrentProgress","currentProgressIndex","setCurrentProgressIndex","connHistory","v","GridModel","progressSlide","Slider","onChange","e","min","max","marks","disabled","routingHistory","CssBaseline","ThemeProvider","AppBar","position","Toolbar","Typography","variant","noWrap","RadioGroup","aria-label","name","value","event","target","FormControlLabel","control","Radio","label","Drawer","open","paper","padding","anchor","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.e7478375.chunk.js","sourcesContent":["import { unstable_createMuiStrictModeTheme as createMuiTheme } from \"@material-ui/core\";\n\nconst theme = createMuiTheme({\n  palette: {\n    primary: {\n      main: \"#203040\",\n    },\n    secondary: {\n      main: \"#abc\",\n    },\n  },\n});\n\nexport default theme;\n","const NetColors = [\n  \"#ff6347\",\n  \"#92da26\", // adff2f\n  \"#4682b4\",\n  \"#F4A460\",\n  \"#dda0dd\",\n\n  \"#6a5acd\",\n  \"#06D6A0\",\n  \"#106b3c\",\n];\n\nexport default NetColors;\n","import { useState, useEffect } from \"react\";\nimport { RouteResult, RouteResultCell } from \"../Models/RouteResult\";\nimport { RouteMap } from \"../Models/RouteMap\";\nimport { Grid as GridModel } from \"../Models/Grid\";\nimport \"./Grid.css\";\nimport NetColors from \"./NetColorTheme\";\n\nexport class RouteMapCellAttr {\n  isWall = false;\n  isPin = false;\n  netID = -1;\n}\n\nfunction makeRouteMapGrid(routeMap: RouteMap): Array<Array<RouteMapCellAttr>> {\n  const grid = Array(routeMap.size.row)\n    .fill(null)\n    .map((nouse, i) => {\n      return Array(routeMap.size.col)\n        .fill(null)\n        .map((nouse, j) => {\n          return { isWall: false, isPin: false, netID: -1 };\n        });\n    });\n\n  routeMap.walls.forEach(([i, j]) => {\n    grid[i][j].isWall = true;\n  });\n\n  routeMap.nets.forEach((net) => {\n    net.pins.forEach(([i, j]) => {\n      grid[i][j].isPin = true;\n      grid[i][j].netID = net.netID;\n    });\n  });\n\n  return grid;\n}\n\nexport interface ProgressCell {\n  visited: number;\n  active: boolean;\n}\n\ntype GridProps = {\n  circuit: RouteMap;\n  segments: RouteResult | undefined;\n  progress: GridModel<ProgressCell> | undefined;\n};\nexport default function Grid({ circuit, segments, progress }: GridProps) {\n  const [routeMapGrid, setRouteMapGrid] = useState(() =>\n    makeRouteMapGrid(circuit)\n  );\n  useEffect(() => {\n    setRouteMapGrid(makeRouteMapGrid(circuit));\n  }, [circuit]);\n\n  return (\n    <div>\n      {routeMapGrid.map((row, i) => {\n        return (\n          <div key={`grid-row ${i}`} className=\"grid-row\">\n            {row.map((cell, j) => {\n              return (\n                <GridCell\n                  key={`grid-cell ${i} ${j}`}\n                  mapCell={cell}\n                  segment={segments?.grid[i][j]}\n                  progress={progress?.grid[i][j]}\n                />\n              );\n            })}\n          </div>\n        );\n      })}\n    </div>\n  );\n}\n\ntype GridCellProps = {\n  mapCell: RouteMapCellAttr;\n  segment: RouteResultCell | undefined;\n  progress: ProgressCell | undefined;\n};\nexport function GridCell({ mapCell, segment, progress }: GridCellProps) {\n  let color = \"#ccc\";\n  if (mapCell.isWall) {\n    color = \"black\";\n  } else if (mapCell.isPin) {\n    color = NetColors[mapCell.netID];\n  }\n\n  if (segment) {\n    if (segment.netId !== -1) {\n      color = NetColors[segment.netId];\n    }\n  }\n\n  const shadow =\n    segment?.netId === -1 &&\n    !mapCell.isPin &&\n    progress &&\n    progress.visited >= 0;\n  return (\n    <div className=\"grid-cell\" style={{ backgroundColor: color }}>\n      <div className={mapCell.isPin ? \"pin cell-overlap\" : \"\"} />\n      {/* <div className=\"cell-overlap mark\">\n        {progress && (progress.visited >= 0 ? \"x\" : \"\")}\n      </div> */}\n      <div className={shadow ? \"visited cell-overlap\" : \"\"}></div>\n    </div>\n  );\n}\n","import {\n  CheckCircle as CheckIcon,\n  ErrorOutline as ErrorOutlineIcon,\n  RemoveCircle as BannedIcon,\n} from \"@material-ui/icons\";\nimport { Box } from \"@material-ui/core\";\n\nimport {\n  IntermediateRouteFailAll,\n  IntermediateRouteFailNet,\n  IntermediateRouteSucceed,\n} from \"../Routers/RouteResults\";\nimport NetColors from \"./NetColorTheme\";\nimport \"./RouteProgressEntry.css\";\nimport { v4 as uuidv4 } from \"uuid\";\n\ntype ConnectedSucceedProps = {\n  result: IntermediateRouteSucceed;\n};\nexport function ConnectSucceed({ result }: ConnectedSucceedProps) {\n  const id = uuidv4();\n  return (\n    <div className=\"entry-row\">\n      <Box color=\"success.main\" className=\"icon-alignment\">\n        <CheckIcon fontSize=\"small\" />\n      </Box>\n      <div className=\"history-list\">\n        {result.connectionHistory.map((conn, i) => {\n          return (\n            <div\n              key={`${id} ${i}`}\n              className=\"history-cell\"\n              style={{ backgroundColor: NetColors[conn.netID] }}\n            ></div>\n          );\n        })}\n        <div\n          className=\"history-cell\"\n          style={{ backgroundColor: NetColors[result.newConnection.netID] }}\n        ></div>\n      </div>\n    </div>\n  );\n}\n\ntype ConnectFailNetProps = {\n  result: IntermediateRouteFailNet;\n};\nexport function ConnectFailNet({ result }: ConnectFailNetProps) {\n  const id = uuidv4();\n  return (\n    <div className=\"entry-row\">\n      <Box color=\"error.main\" className=\"icon-alignment\">\n        <ErrorOutlineIcon fontSize=\"small\" />\n      </Box>\n      <div className=\"history-list\">\n        {result.connectionHistory.map((conn, i) => {\n          return (\n            <div\n              key={`${id} ${i}`}\n              className=\"history-cell\"\n              style={{ backgroundColor: NetColors[conn.netID] }}\n            ></div>\n          );\n        })}\n        <div\n          className=\"history-cell\"\n          style={{ backgroundColor: NetColors[result.failedNet.netID] }}\n        ></div>\n      </div>\n    </div>\n  );\n}\n\ntype ConnectFailAllProps = {\n  result: IntermediateRouteFailAll;\n};\nexport function ConnectFailAll({ result }: ConnectFailAllProps) {\n  const id = uuidv4();\n  return (\n    <div className=\"entry-row\">\n      <Box color=\"error.main\" className=\"icon-alignment\">\n        <BannedIcon fontSize=\"small\" />\n      </Box>\n      <div className=\"history-list\">\n        {result.connectionHistory.map((conn, i) => {\n          return (\n            <div\n              key={`${id} ${i}`}\n              className=\"history-cell\"\n              style={{ backgroundColor: NetColors[conn.netID] }}\n            ></div>\n          );\n        })}\n      </div>\n    </div>\n  );\n}\n","import Connection from \"../Models/Connection\";\nimport { Grid } from \"../Models/Grid\";\nimport { Coors, Net } from \"../Models/RouteMap\";\n\nexport interface ConnectionRoutingResult {\n  succeed: boolean;\n}\n\nexport interface ConnectionRoutingSuccess extends ConnectionRoutingResult {\n  connectedPin: Coors;\n  segments: Array<Coors>;\n}\n\nexport interface NetRoutingResult {\n  succeed: boolean;\n}\nexport interface NetRoutingSuccess extends NetRoutingResult {\n  connection: Connection;\n}\n\n////////\n\nexport interface MapRouteResult {\n  succeed: boolean;\n}\n\nexport interface MapRouteSuccess extends MapRouteResult {\n  netRouteSequence: Array<Net>;\n  connections: Array<Connection>;\n}\n\nexport interface IntermediateRouteSucceed extends IntermediateRouteResult {\n  connectionHistory: Array<Connection>;\n  newConnection: Connection;\n}\n\nexport interface IntermediateRouteFailNet extends IntermediateRouteResult {\n  connectionHistory: Array<Connection>;\n  failedNet: Net;\n}\n\nexport interface IntermediateRouteFailAll extends IntermediateRouteResult {\n  connectionHistory: Array<Connection>;\n}\n\nexport enum IntermediateRouteResultType {\n  Succeed = 0,\n  FailNet,\n  FailAll,\n}\n\nexport interface IntermediateRouteResult {\n  type: IntermediateRouteResultType;\n}\n\n/////\nexport type ConnectionProgress =\n  | {\n      type: \"expand\";\n      progress: ExpandProgress;\n    }\n  | {\n      type: \"backtrack\";\n      progress: BacktrackProgress;\n    };\n\nexport class ExpandProgress {\n  constructor(public visited: Grid<number>, public active: Grid<boolean>) {}\n}\n\nexport class BacktrackProgress {\n  constructor(\n    public visited: Grid<number>,\n    public segHistory: Array<Coors>,\n    public newSegment: Coors\n  ) {}\n}\n","export interface GridSize {\n  col: number;\n  row: number;\n}\n\nexport class Grid<T> {\n  grid: Array<Array<T>>;\n  size: GridSize;\n\n  constructor(size: GridSize, initializer: (i: number, j: number) => T) {\n    this.size = size;\n    this.grid = Array(size.row)\n      .fill(null)\n      .map((nouse, i) =>\n        Array(size.col)\n          .fill(null)\n          .map((nouse, j) => initializer(i, j))\n      );\n  }\n\n  map<U>(fn: (val: T, i: number, j: number) => U) {\n    return {\n      size: { ...this.size },\n      grid: this.grid.map((row: Array<T>, i) => {\n        return row.map((val: T, j) => {\n          return fn(val, i, j);\n        });\n      }),\n    } as Grid<U>;\n  }\n\n  copyNumber() {\n    return {\n      size: { ...this.size },\n      grid: this.grid.map((row) => {\n        return [...row];\n      }),\n    } as Grid<T>;\n  }\n}\n","import Connection from \"../Models/Connection\";\nimport { Grid, GridSize } from \"../Models/Grid\";\nimport { Coors, Net, RouteMap } from \"../Models/RouteMap\";\nimport { RouteResultCell } from \"../Models/RouteResult\";\n\nexport function makeTargetGrid(size: GridSize, targets: Array<Coors>) {\n  const grid = new Grid(size, (i, j) => {\n    return false;\n  });\n\n  targets.forEach(([i, j]) => {\n    grid.grid[i][j] = true;\n  });\n\n  return grid;\n}\n\nexport function adjacentCoors(i: number, j: number): Array<Coors> {\n  return [\n    [i + 1, j],\n    [i - 1, j],\n    [i, j + 1],\n    [i, j - 1],\n  ];\n}\n\nexport function makeObstacleGrid(\n  routeMap: RouteMap,\n  net: Net,\n  routedConnections: Array<Connection>\n) {\n  const routingNetID = net.netID;\n  const grid = new Grid(routeMap.size, (i, j) => {\n    return false;\n  });\n\n  /// walls are obstacles\n  routeMap.walls.forEach(([i, j]) => {\n    grid.grid[i][j] = true;\n  });\n\n  /// net pins that are not in the routing net are obstacles\n  routeMap.nets\n    .filter((net) => net.netID !== routingNetID)\n    .forEach((net) => {\n      net.pins.forEach(([i, j]) => {\n        grid.grid[i][j] = true;\n      });\n    });\n\n  /// routed connection are obstacles\n  routedConnections.forEach((connection) => {\n    connection.segments.forEach(([i, j]) => {\n      grid.grid[i][j] = true;\n    });\n  });\n\n  return grid;\n}\n\nexport function makeRouteResultGridFromConnections(\n  size: GridSize,\n  connections: Array<Connection>\n) {\n  const grid = new Grid<RouteResultCell>(size, (i, j) => ({\n    netId: -1,\n  }));\n  connections.forEach((conn) => {\n    conn.segments.forEach(([i, j]) => {\n      grid.grid[i][j].netId = conn.netID;\n    });\n  });\n  return grid;\n}\n","import Connection from \"../Models/Connection\";\nimport { Grid } from \"../Models/Grid\";\nimport { Coors, Net, RouteMap } from \"../Models/RouteMap\";\nimport {\n  adjacentCoors,\n  makeObstacleGrid,\n  makeRouteResultGridFromConnections,\n  makeTargetGrid,\n} from \"./utils\";\nimport {\n  ConnectionRoutingResult,\n  ConnectionRoutingSuccess,\n  IntermediateRouteFailAll,\n  IntermediateRouteFailNet,\n  IntermediateRouteResult,\n  IntermediateRouteResultType,\n  IntermediateRouteSucceed,\n  MapRouteResult,\n  MapRouteSuccess,\n  NetRoutingResult,\n  NetRoutingSuccess,\n  ExpandProgress,\n  BacktrackProgress,\n  ConnectionProgress,\n} from \"./RouteResults\";\nimport { RouteResultCell } from \"../Models/RouteResult\";\nimport aStarRoute from \"./aStarRoute\";\n\nexport const buildExpandProgress = (progressGrid: Grid<number>) => {\n  return new ExpandProgress(\n    progressGrid.copyNumber(),\n    progressGrid.map((val) => {\n      return val === -2;\n    })\n  );\n};\n\nexport class ConnectionRouteHistory {\n  constructor(\n    public progress: Array<ConnectionProgress>,\n    public sources: Coors[]\n  ) {}\n}\n\nexport type ConnectionRouter = (\n  obstacleGrid: Grid<boolean>,\n  sources: Array<Coors>,\n  targetGrid: Grid<boolean>,\n  historyRecord?: ConnectionRouteHistory\n) => ConnectionRoutingResult;\n\nexport function dijkstraRoute(\n  obstacleGrid: Grid<boolean>,\n  sources: Array<Coors>,\n  targetGrid: Grid<boolean>,\n  historyRecord?: ConnectionRouteHistory\n): ConnectionRoutingResult {\n  const { col, row } = obstacleGrid.size;\n  const progressGrid = new Grid<number>(obstacleGrid.size, (i, j) => -1);\n  const inRange = (i: number, j: number) =>\n    i >= 0 && i < row && j >= 0 && j < col;\n  const canExpand = (i: number, j: number) =>\n    inRange(i, j) && !obstacleGrid.grid[i][j] && progressGrid.grid[i][j] === -1;\n\n  /// expansion\n  let expansionList = sources;\n  let iExpand = 0;\n  let connectedTargetCoors: Coors | null = null;\n  while (expansionList.length > 0) {\n    const newExpansionList = [] as Array<Coors>;\n\n    for (const [i, j] of expansionList) {\n      progressGrid.grid[i][j] = iExpand;\n    }\n    for (const [i, j] of expansionList) {\n      for (const [ni, nj] of adjacentCoors(i, j)) {\n        if (canExpand(ni, nj)) {\n          newExpansionList.push([ni, nj]);\n          progressGrid.grid[ni][nj] = -2;\n          /// whether found one of the targets\n          if (targetGrid.grid[ni][nj]) {\n            connectedTargetCoors = [ni, nj];\n          }\n        }\n      }\n    }\n    /// whether found target\n    if (connectedTargetCoors) {\n      expansionList = [];\n    } else {\n      expansionList = newExpansionList;\n      iExpand++;\n    }\n    if (historyRecord)\n      historyRecord.progress.push({\n        type: \"expand\",\n        progress: buildExpandProgress(progressGrid),\n      });\n  }\n\n  if (!connectedTargetCoors) {\n    return { succeed: false };\n  }\n\n  /// backtrack\n  const nExpand = iExpand;\n  let [i, j]: Coors = connectedTargetCoors;\n  let iPrevLayer = nExpand;\n  const segments: Array<Coors> = [];\n  while (true) {\n    /* eslint-disable no-loop-func */\n    [i, j] = adjacentCoors(i, j).filter(([ni, nj]) => {\n      return inRange(ni, nj) && progressGrid.grid[ni][nj] === iPrevLayer;\n    })[0];\n    /* eslint-enable no-loop-func */\n\n    if (historyRecord)\n      historyRecord.progress.push({\n        type: \"backtrack\",\n        progress: new BacktrackProgress(progressGrid, [...segments], [i, j]),\n      });\n\n    if (progressGrid.grid[i][j] === 0) break;\n    segments.push([i, j]);\n    iPrevLayer--;\n  }\n\n  return {\n    succeed: true,\n    segments,\n    connectedPin: connectedTargetCoors,\n  } as ConnectionRoutingSuccess;\n}\n\nexport class NetRouteHistory {\n  constructor(\n    public net: Net,\n    public segmentGrid: Grid<RouteResultCell>,\n    public connectionHistories: Array<ConnectionRouteHistory>\n  ) {}\n}\n\nexport function routeNet(\n  obstacleGrid: Grid<boolean>,\n  net: Net,\n  connectionRouter: ConnectionRouter,\n  historyRecord?: NetRouteHistory\n): NetRoutingResult {\n  const [sourcePin, ...targets] = net.pins;\n  let sources = [sourcePin];\n  const targetGrid = makeTargetGrid(obstacleGrid.size, targets);\n  let nTargets = targets.length;\n\n  const getConnectionHistory = () => {\n    if (historyRecord) {\n      const ch = new ConnectionRouteHistory([], [...sources]);\n      historyRecord.connectionHistories.push(ch);\n      return ch;\n    } else {\n      return undefined;\n    }\n  };\n\n  while (nTargets > 0) {\n    const h = getConnectionHistory();\n    const result = connectionRouter(obstacleGrid, sources, targetGrid, h);\n    /// fail to route this net if connection route is fail\n    if (!result.succeed) break;\n    const success = result as ConnectionRoutingSuccess;\n\n    /// update sources and targets\n    nTargets -= 1;\n    sources = [...sources, ...success.segments, success.connectedPin];\n    const [ci, cj] = success.connectedPin; // connected pin coor\n    targetGrid.grid[ci][cj] = false;\n  }\n\n  if (nTargets > 0) {\n    return { succeed: false };\n  } else {\n    return {\n      succeed: true,\n      connection: {\n        netID: net.netID,\n        segments: sources,\n      },\n    } as NetRoutingSuccess;\n  }\n}\n\nexport class CircuitRouteHistory {\n  constructor(public netHistories: Array<NetRouteHistory>) {}\n}\n\nexport const routeCircuitUntilFail = (\n  routeMap: RouteMap,\n  netSequence: Array<Net>,\n  historyRecord: CircuitRouteHistory,\n  connectionRouter: ConnectionRouter\n) => {\n  const routedConnections: Array<Connection> = [];\n  for (const net of netSequence) {\n    const wireGrid = makeRouteResultGridFromConnections(\n      routeMap.size,\n      routedConnections\n    );\n    const netHistory = new NetRouteHistory(net, wireGrid, []);\n    historyRecord.netHistories.push(netHistory);\n\n    const obstacleGrid = makeObstacleGrid(routeMap, net, routedConnections);\n    const netResult = routeNet(obstacleGrid, net, connectionRouter, netHistory);\n    if (!netResult.succeed) break;\n    const succeed = netResult as NetRoutingSuccess;\n    routedConnections.push(succeed.connection);\n  }\n};\n\nexport function routeCircuit(\n  routeMap: RouteMap,\n  yieldResultCallback: (arg0: IntermediateRouteResult) => void,\n  connectionRouter: ConnectionRouter\n): MapRouteResult {\n  function tryToRoute(\n    nets: Array<Net>,\n    routedConnections: Array<Connection>\n  ): MapRouteResult {\n    if (nets.length === 0) {\n      return {\n        succeed: true,\n        netRouteSequence: [],\n        connections: [],\n      } as MapRouteSuccess;\n    }\n\n    for (let i = 0; i < nets.length; i++) {\n      const net = nets[i];\n\n      /// try to route the net\n      const obstacleGrid = makeObstacleGrid(routeMap, net, routedConnections);\n      const netResult = routeNet(obstacleGrid, net, connectionRouter);\n      if (!netResult.succeed) {\n        yieldResultCallback({\n          type: IntermediateRouteResultType.FailNet,\n          connectionHistory: routedConnections,\n          failedNet: net,\n        } as IntermediateRouteFailNet);\n        continue;\n      }\n      const netSucceed = netResult as NetRoutingSuccess;\n      yieldResultCallback({\n        type: IntermediateRouteResultType.Succeed,\n        connectionHistory: routedConnections,\n        newConnection: netSucceed.connection,\n      } as IntermediateRouteSucceed);\n\n      /// if this net can be connected => try route other nets\n      const otherNets = [...nets.slice(0, i), ...nets.slice(i + 1)];\n      const otherNetResult = tryToRoute(otherNets, [\n        ...routedConnections,\n        netSucceed.connection,\n      ]);\n      if (otherNetResult.succeed) {\n        const otherNetSucceed = otherNetResult as MapRouteSuccess;\n        return {\n          succeed: true,\n          netRouteSequence: [net, ...otherNetSucceed.netRouteSequence],\n          connections: [netSucceed.connection, ...otherNetSucceed.connections],\n        } as MapRouteSuccess;\n      }\n    }\n\n    yieldResultCallback({\n      type: IntermediateRouteResultType.FailAll,\n      connectionHistory: routedConnections,\n    } as IntermediateRouteFailAll);\n    return { succeed: false };\n  }\n\n  return tryToRoute(routeMap.nets, []);\n}\n","import { GridSize } from \"./Grid\";\n\nexport enum MapCellType {\n  void = 0,\n  wall,\n  pin,\n}\n\nexport type Coors = [number, number];\nexport interface Net {\n  netID: number;\n  pins: Array<Coors>;\n}\n\nexport interface RouteMap {\n  size: GridSize;\n  walls: Array<Coors>;\n  nets: Array<Net>;\n}\n\nexport function parseRoutingMapString(input: string): RouteMap {\n  const lines = input.split(\"\\n\");\n  const [nCol, nRow] = lines[0].split(\" \").map((a) => parseInt(a));\n  let i_line = 1;\n\n  /// parse obstacles\n  const n_wall = parseInt(lines[i_line++]);\n  const walls = lines.slice(i_line, i_line + n_wall).map((line) => {\n    const [j, i] = line.split(\" \").map((a) => parseInt(a));\n    return [i, j] as Coors;\n  });\n  i_line += n_wall;\n\n  /// parse nets\n  const nets: Array<Net> = [];\n  const n_net = parseInt(lines[i_line++]);\n  lines.slice(i_line, i_line + n_net).forEach((line, netID) => {\n    /// parse pins\n    const [, ...coors] = line\n      .trim()\n      .split(\" \")\n      .map((a) => parseInt(a));\n    const net: Net = { netID: netID, pins: [] };\n    for (let idx = 0; idx < coors.length; idx += 2) {\n      const j = coors[idx],\n        i = coors[idx + 1];\n      net.pins.push([i, j]);\n    }\n    nets.push(net);\n  });\n\n  return {\n    size: { col: nCol, row: nRow },\n    walls: walls,\n    nets: nets,\n  };\n}\n","import { List, ListItem } from \"@material-ui/core\";\nimport axios from \"axios\";\nimport { useEffect, useState } from \"react\";\nimport { parseRoutingMapString, RouteMap } from \"../Models/RouteMap\";\n\nexport function useRouteMapSelector(setRouteMap: (arg0: RouteMap) => void) {\n  const [infiles, setInfiles] = useState<Array<string>>();\n  useEffect(() => {\n    axios.get(\"benchmarks/infiles.json\").then((res) => {\n      setInfiles(res.data);\n    });\n    return () => {};\n  }, []);\n\n  const [mapName, setMapName] = useState(\"rusty.infile\");\n  useEffect(() => {\n    if (mapName === \"\") return;\n    axios.get<string>(`benchmarks/${mapName}`).then((res) => {\n      setRouteMap(parseRoutingMapString(res.data));\n    });\n\n    /// TODO clean up\n  }, [mapName, setRouteMap]);\n\n  const routeMapSelector = (\n    <List>\n      {infiles?.map((filename) => (\n        <ListItem\n          button\n          key={filename}\n          onClick={() => setMapName(filename)}\n          selected={filename === mapName}\n        >\n          {filename.split(\".\")[0]}\n        </ListItem>\n      ))}\n    </List>\n  );\n\n  return { routeMapSelector, mapName };\n}\n","import { Grid } from \"../Models/Grid\";\nimport { Coors } from \"../Models/RouteMap\";\nimport { ConnectionRouteHistory } from \"./Router\";\nimport {\n  BacktrackProgress,\n  ConnectionProgress,\n  ConnectionRoutingResult,\n  ConnectionRoutingSuccess,\n  ExpandProgress,\n} from \"./RouteResults\";\nimport { adjacentCoors } from \"./utils\";\nimport PriorityQueue from \"js-priority-queue\";\nimport { GridCell } from \"../Components/Grid\";\n\nconst coorsDist = (a: Coors, b: Coors) => {\n  return a[0] - b[0] + (a[1] - b[1]);\n};\n\nclass QueueItem {\n  dist: number;\n  constructor(public coors: Coors, targets: Coors[], iExpand: number) {\n    let [closest, ...others] = targets;\n    let minDist = coorsDist(closest, coors);\n    for (const c of others) {\n      const d = coorsDist(c, coors);\n      if (minDist > d) {\n        minDist = d;\n        closest = c;\n      }\n    }\n    this.dist = minDist + iExpand;\n  }\n}\n\nconst buildExpandProgress = (\n  progressGrid: Grid<number>,\n  queue: any\n): ConnectionProgress => {\n  const active = new Grid<boolean>(progressGrid.size, (i, j) => false);\n\n  return {\n    type: \"expand\",\n    progress: new ExpandProgress(\n      progressGrid.map((a) => a),\n      active\n    ),\n  };\n};\n\nconst compareItem = (a: QueueItem, b: QueueItem) => {\n  return a.dist - b.dist;\n};\n\nconst buildQueue = (sources: Coors[], targets: Coors[]) => {\n  let queue = new PriorityQueue<QueueItem>({ comparator: compareItem });\n  for (const s of sources) {\n    queue.queue(new QueueItem(s, targets, 0));\n  }\n  return queue;\n};\n\nconst popAllEqualDist = (queue: PriorityQueue<QueueItem>) => {\n  const coorsList: Coors[] = [];\n  if (queue.length === 0) return coorsList;\n\n  const minDist = queue.peek().dist;\n  while (queue.length > 0 && queue.peek().dist === minDist) {\n    coorsList.push(queue.dequeue().coors);\n  }\n  return coorsList;\n};\n\nconst convertTargetGridToList = (targetGrid: Grid<boolean>) => {\n  const list: Coors[] = [];\n  targetGrid.grid.forEach((row, i) => {\n    row.forEach((isTarget, j) => {\n      if (isTarget) list.push([i, j]);\n    });\n  });\n  return list;\n};\n\nexport default function aStarRoute(\n  obstacleGrid: Grid<boolean>,\n  sources: Coors[],\n  targetGrid: Grid<boolean>,\n  historyRecord?: ConnectionRouteHistory\n): ConnectionRoutingResult {\n  const { col, row } = obstacleGrid.size;\n  const progressGrid = new Grid(obstacleGrid.size, (i, j) => -1);\n  const expandFromGrid = new Grid(\n    obstacleGrid.size,\n    (i, j): Coors | null => null\n  );\n  const inRange = (i: number, j: number) =>\n    i >= 0 && i < row && j >= 0 && j < col;\n  const canExpand = (i: number, j: number) =>\n    inRange(i, j) && !obstacleGrid.grid[i][j] && progressGrid.grid[i][j] === -1;\n  const targets = convertTargetGridToList(targetGrid);\n\n  /// expansion\n  let isStart = true;\n  const queue = buildQueue(sources, targets);\n  let iExpand = 1;\n  // let iExpand = 0;\n  let connectedTargetCoors: Coors | null = null;\n  while (queue.length > 0) {\n    const expansionList = popAllEqualDist(queue);\n\n    for (const [i, j] of expansionList) {\n      progressGrid.grid[i][j] = isStart ? 0 : 1;\n      isStart = false;\n    }\n    for (const [i, j] of expansionList) {\n      for (const [ni, nj] of adjacentCoors(i, j)) {\n        if (canExpand(ni, nj)) {\n          queue.queue(new QueueItem([ni, nj], targets, iExpand));\n          expandFromGrid.grid[ni][nj] = [i, j];\n\n          progressGrid.grid[ni][nj] = -2;\n          /// whether found one of the targets\n          if (targetGrid.grid[ni][nj]) {\n            connectedTargetCoors = [ni, nj];\n          }\n        }\n      }\n    }\n    /// whether found target\n    if (connectedTargetCoors) {\n      queue.clear();\n    } else {\n      iExpand++;\n    }\n\n    if (historyRecord)\n      historyRecord.progress.push(buildExpandProgress(progressGrid, queue));\n  }\n\n  if (!connectedTargetCoors) {\n    return { succeed: false };\n  }\n\n  /// backtrack\n  let [i, j]: Coors = connectedTargetCoors;\n  const segments: Array<Coors> = [];\n  while (true) {\n    try {\n      [i, j] = expandFromGrid.grid[i][j] as Coors;\n    } catch (error) {\n      // console.log({ i, j, grid: expandFromGrid.grid[i][j] });\n      break;\n    }\n\n    if (historyRecord)\n      historyRecord.progress.push({\n        type: \"backtrack\",\n        progress: new BacktrackProgress(progressGrid, [...segments], [i, j]),\n      });\n\n    if (progressGrid.grid[i][j] === 0) break;\n    segments.push([i, j]);\n  }\n\n  return {\n    succeed: true,\n    segments,\n    connectedPin: connectedTargetCoors,\n  } as ConnectionRoutingSuccess;\n}\n","import React, { useEffect, useState } from \"react\";\nimport {\n  AppBar,\n  createStyles,\n  CssBaseline,\n  Drawer,\n  FormControlLabel,\n  List,\n  ListItem,\n  makeStyles,\n  Radio,\n  RadioGroup,\n  Theme,\n  ThemeProvider,\n  Toolbar,\n  Typography,\n} from \"@material-ui/core\";\nimport Slider from \"@material-ui/core/Slider\";\n\n/// User Component Imports\nimport theme from \"./theme\";\nimport \"./App.css\";\nimport Grid, { ProgressCell } from \"./Components/Grid\";\nimport {\n  ConnectSucceed,\n  ConnectFailAll,\n  ConnectFailNet,\n} from \"./Components/RouteProgressEntry\";\n\n/// User Model Imports\nimport { Grid as GridModel } from \"./Models/Grid\";\nimport { RouteMap } from \"./Models/RouteMap\";\nimport {\n  CircuitRouteHistory,\n  ConnectionRouteHistory,\n  dijkstraRoute,\n  NetRouteHistory,\n  routeCircuit,\n  routeCircuitUntilFail,\n} from \"./Routers/Router\";\nimport { RouteResult } from \"./Models/RouteResult\";\nimport { useRouteMapSelector } from \"./Components/useRouteMapSelector\";\nimport {\n  ConnectionProgress,\n  IntermediateRouteFailAll,\n  IntermediateRouteFailNet,\n  IntermediateRouteResult,\n  IntermediateRouteResultType,\n  IntermediateRouteSucceed,\n  MapRouteSuccess,\n} from \"./Routers/RouteResults\";\nimport { makeRouteResultGridFromConnections } from \"./Routers/utils\";\nimport aStarRoute from \"./Routers/aStarRoute\";\n\nconst circuitDrawerWidth = 150;\nconst historyDrawerWidth = 200;\nconst useStyles = makeStyles((theme: Theme) =>\n  createStyles({\n    root: {\n      display: \"flex\",\n    },\n    appBar: {\n      width: `calc(100% - ${circuitDrawerWidth}px - ${historyDrawerWidth}px)`,\n      left: circuitDrawerWidth,\n    },\n    circuitDrawer: {\n      width: circuitDrawerWidth,\n      flexShrink: 0,\n    },\n    circuitDrawerPaper: {\n      width: circuitDrawerWidth,\n    },\n    historyDrawer: {\n      width: historyDrawerWidth,\n    },\n    historyDrawerPaper: {\n      width: historyDrawerWidth,\n      flexShrink: 0,\n    },\n    // necessary for content to be below app bar\n    toolbar: theme.mixins.toolbar,\n    content: {\n      flexGrow: 1,\n      backgroundColor: theme.palette.background.default,\n    },\n  })\n);\n\nconst buildRouteProgress = (progress: CircuitRouteHistory) => {\n  const currentProgress: Array<\n    [NetRouteHistory, ConnectionRouteHistory, ConnectionProgress]\n  > = [];\n  for (const netH of progress.netHistories) {\n    for (const connH of netH.connectionHistories) {\n      for (const p of connH.progress) {\n        currentProgress.push([netH, connH, p]);\n      }\n    }\n  }\n  return currentProgress;\n};\n\nfunction App() {\n  const [routeResult, setRouteResult] = useState<RouteResult>();\n  const [routeMap, setRouteMap] = useState<RouteMap>();\n  const [progressGrid, setProgressGrid] = useState<GridModel<ProgressCell>>();\n  const [routerName, setRouterName] = useState(\"dijkstra\");\n  const classes = useStyles();\n\n  const { routeMapSelector, mapName } = useRouteMapSelector(setRouteMap);\n\n  const [routeHistories, setRouteHistories] = useState(\n    [] as Array<IntermediateRouteResult>\n  );\n\n  let maxNetConnections = [0];\n  const innerResultCallback = (result: IntermediateRouteResult) => {\n    setRouteHistories((prev) => {\n      if (prev.length > 100) return prev;\n      if (result.type === IntermediateRouteResultType.Succeed) {\n        let nConnection =\n          (result as IntermediateRouteSucceed).connectionHistory.length + 1;\n\n        if (nConnection > maxNetConnections[0]) {\n          maxNetConnections[0] = nConnection;\n        }\n      }\n      return [...prev, result];\n    });\n  };\n\n  const [\n    currentHistory,\n    setCurrentHistory,\n  ] = useState<IntermediateRouteResult>();\n\n  useEffect(() => {\n    if (!routeMap) return;\n\n    setCurrentHistory(undefined);\n    setRouteHistories([]);\n    setProgressGrid(undefined);\n\n    maxNetConnections[0] = 0;\n    const routeResult = routeCircuit(\n      routeMap,\n      innerResultCallback,\n      routerName !== \"dijkstra\" ? aStarRoute : dijkstraRoute\n    );\n    console.log({ maxNetConnections });\n\n    if (!routeResult.succeed) {\n      setRouteResult(undefined);\n      return;\n    }\n    const succeed = routeResult as MapRouteSuccess;\n    // console.log(succeed);\n\n    const grid = makeRouteResultGridFromConnections(\n      routeMap.size,\n      succeed.connections\n    );\n    setRouteResult(grid);\n  }, [routeMap, routerName]);\n\n  useEffect(() => {\n    if (!routeMap) return;\n    if (!currentHistory) return;\n\n    switch (currentHistory.type) {\n      case IntermediateRouteResultType.Succeed:\n        {\n          const succeed = currentHistory as IntermediateRouteSucceed;\n          const grid = makeRouteResultGridFromConnections(routeMap.size, [\n            ...succeed.connectionHistory,\n            succeed.newConnection,\n          ]);\n          setRouteResult(grid);\n        }\n        break;\n      case IntermediateRouteResultType.FailNet:\n        {\n          const failNet = currentHistory as IntermediateRouteFailNet;\n          const grid = makeRouteResultGridFromConnections(\n            routeMap.size,\n            failNet.connectionHistory\n          );\n          setRouteResult(grid);\n        }\n        break;\n      case IntermediateRouteResultType.FailAll:\n        break;\n      default:\n        console.error(\"should not reach here\");\n    }\n    /// TODO: figure out why adding routeMap leads to problem\n  }, [currentHistory]); // eslint-disable-line react-hooks/exhaustive-deps\n\n  const [currentProgress, setCurrentProgress] = useState<\n    Array<[NetRouteHistory, ConnectionRouteHistory, ConnectionProgress]>\n  >();\n  useEffect(() => {\n    if (!routeMap) return;\n    if (!currentHistory) return;\n\n    switch (currentHistory.type) {\n      case IntermediateRouteResultType.Succeed:\n        {\n          const succeed = currentHistory as IntermediateRouteSucceed;\n\n          const progress = new CircuitRouteHistory([]);\n          routeCircuitUntilFail(\n            routeMap,\n            [...succeed.connectionHistory, succeed.newConnection]\n              .map((conn) => conn.netID)\n              .map((id) => routeMap.nets[id]),\n            progress,\n            routerName !== \"dijkstra\" ? aStarRoute : dijkstraRoute\n          );\n\n          setCurrentProgress(buildRouteProgress(progress));\n        }\n        break;\n      case IntermediateRouteResultType.FailNet:\n        {\n          const failNet = currentHistory as IntermediateRouteFailNet;\n\n          const progress = new CircuitRouteHistory([]);\n          routeCircuitUntilFail(\n            routeMap,\n            [\n              ...failNet.connectionHistory\n                .map((conn) => conn.netID)\n                .map((id) => routeMap.nets[id]),\n              failNet.failedNet,\n            ],\n            progress,\n            routerName !== \"dijkstra\" ? aStarRoute : dijkstraRoute\n          );\n\n          setCurrentProgress(buildRouteProgress(progress));\n        }\n        break;\n      case IntermediateRouteResultType.FailAll:\n        break;\n      default:\n        console.error(\"should not reach here\");\n    }\n  }, [currentHistory, routerName]);\n\n  useEffect(() => {\n    if (!currentProgress) return;\n    // console.log(currentProgress);\n  }, [currentProgress]);\n\n  const [currentProgressIndex, setCurrentProgressIndex] = useState(0);\n\n  useEffect(() => {\n    if (!routeMap || !currentProgress || currentProgressIndex === undefined)\n      return;\n\n    // console.log(currentProgress[currentProgressIndex]);\n\n    const [netHistory, connHistory, progress] = currentProgress[\n      currentProgressIndex\n    ];\n\n    const segmentGrid = netHistory.segmentGrid.map((v) => ({ ...v }));\n    connHistory.sources.forEach(([i, j]) => {\n      segmentGrid.grid[i][j].netId = netHistory.net.netID;\n    });\n    if (progress.type === \"backtrack\") {\n      const { segHistory, newSegment } = progress.progress;\n\n      [...segHistory, newSegment].forEach(([i, j]) => {\n        segmentGrid.grid[i][j].netId = netHistory.net.netID;\n      });\n    }\n\n    setRouteResult(segmentGrid);\n\n    /// set progress grid\n    if (progress.type === \"expand\") {\n      setProgressGrid(\n        new GridModel<ProgressCell>(routeMap.size, (i, j) => {\n          return {\n            visited: progress.progress.visited.grid[i][j],\n            active: progress.progress.active.grid[i][j],\n          } as ProgressCell;\n        })\n      );\n    }\n  }, [currentProgressIndex]);\n\n  useEffect(() => {\n    // console.log(progressGrid);\n  }, [progressGrid]);\n\n  const progressSlide = currentProgress ? (\n    <Slider\n      onChange={(e, val) => setCurrentProgressIndex(val as number)}\n      min={0}\n      max={currentProgress.length - 1}\n      marks\n    />\n  ) : (\n    <Slider disabled />\n  );\n\n  const routingHistory = (\n    <List>\n      {routeHistories.map((result, i) => (\n        <ListItem\n          button\n          key={`history ${i}`}\n          onClick={() => setCurrentHistory(result)}\n          selected={result === currentHistory}\n        >\n          {(() => {\n            switch (result.type) {\n              case IntermediateRouteResultType.Succeed:\n                return (\n                  <ConnectSucceed\n                    result={result as IntermediateRouteSucceed}\n                  ></ConnectSucceed>\n                );\n              case IntermediateRouteResultType.FailNet:\n                return (\n                  <ConnectFailNet\n                    result={result as IntermediateRouteFailNet}\n                  ></ConnectFailNet>\n                );\n              case IntermediateRouteResultType.FailAll:\n                return (\n                  <ConnectFailAll\n                    result={result as IntermediateRouteFailAll}\n                  ></ConnectFailAll>\n                );\n              default:\n                return \"0\";\n            }\n          })()}\n        </ListItem>\n      ))}\n    </List>\n  );\n\n  return (\n    <div className={classes.root}>\n      <CssBaseline />\n      <ThemeProvider theme={theme}>\n        <AppBar position=\"fixed\" className={classes.appBar}>\n          <Toolbar>\n            <Typography variant=\"h6\" noWrap>\n              {mapName}\n            </Typography>\n            <div style={{ flexGrow: 1 }}></div>\n            <RadioGroup\n              row\n              aria-label=\"gender\"\n              name=\"gender1\"\n              value={routerName}\n              onChange={(event) => setRouterName(event.target.value)}\n            >\n              <FormControlLabel\n                value=\"dijkstra\"\n                control={<Radio />}\n                label=\"Lee-Moore\"\n              />\n              <FormControlLabel value=\"aStar\" control={<Radio />} label=\"A*\" />\n            </RadioGroup>\n          </Toolbar>\n        </AppBar>\n        <Drawer\n          open={true}\n          variant=\"permanent\"\n          className={classes.circuitDrawer}\n          classes={{ paper: classes.circuitDrawerPaper }}\n        >\n          {routeMapSelector}\n        </Drawer>\n        <main className={classes.content}>\n          <div className={classes.toolbar} />\n          <div style={{ padding: 20 }}>\n            {routeMap ? (\n              <Grid\n                circuit={routeMap}\n                segments={routeResult}\n                progress={progressGrid}\n              />\n            ) : (\n              <></>\n            )}\n          </div>\n          <div style={{ padding: \"0 20px\" }}>{progressSlide}</div>\n        </main>\n        <Drawer\n          open={true}\n          variant=\"permanent\"\n          className={classes.historyDrawer}\n          classes={{ paper: classes.historyDrawerPaper }}\n          anchor=\"right\"\n        >\n          {routingHistory}\n        </Drawer>\n      </ThemeProvider>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}