{"version":3,"sources":["theme.ts","Components/Grid.tsx","Models/RouteMap.ts","Models/Grid.ts","Routers/Router.ts","App.tsx","index.tsx"],"names":["theme","createMuiTheme","palette","primary","main","secondary","makeRouteMapGrid","routeMap","grid","Array","size","row","fill","map","nouse","i","col","j","isWall","isPin","netID","walls","forEach","nets","net","pins","Grid","routeResult","useState","routeMapGrid","setRouteMapGrid","useEffect","className","cell","GridCell","mapCell","routeResultCell","netColors","color","netId","style","backgroundColor","MapCellType","initializer","this","adjacentCoors","routeConnection","obstacleGrid","sources","targetGrid","progressGrid","inRange","canExpand","expansionList","iExpand","connectedTargetCoors","length","newExpansionList","ni","nj","push","succeed","nExpand","iPrevLayer","segments","filter","connectedPin","routeNet","sourcePin","targets","makeTargetGrid","nTargets","result","success","ci","cj","connection","makeObstacleGrid","routingNetID","routedConnections","App","setRouteResult","setRouteMap","tryToRoute","netRouteSequence","connections","netResult","netSucceed","otherNetResult","slice","otherNetSucceed","route","console","log","GridModel","conn","undefined","infiles","setInfiles","axios","get","then","res","data","mapName","setMapName","input","lines","split","a","parseInt","nCol","nRow","i_line","n_wall","line","n_net","trim","coors","idx","parseRoutingMapString","ThemeProvider","AppBar","position","Toolbar","Select","width","value","onChange","event","target","filename","MenuItem","margin","onClick","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.2ffcfb44.chunk.js","sourcesContent":["import { unstable_createMuiStrictModeTheme as createMuiTheme } from \"@material-ui/core\";\n\nconst theme = createMuiTheme({\n  palette: {\n    primary: {\n      main: \"#203040\",\n    },\n    secondary: {\n      main: \"#abc\",\n    },\n  },\n});\n\nexport default theme;\n","import { useState, useEffect } from \"react\";\nimport { RouteResult, RouteResultCell } from \"../App\";\nimport { RouteMap } from \"../Models/RouteMap\";\nimport \"./Grid.css\";\n\nexport class RouteMapCellAttr {\n  isWall = false;\n  isPin = false;\n  netID = -1;\n}\n\nfunction makeRouteMapGrid(routeMap: RouteMap): Array<Array<RouteMapCellAttr>> {\n  const grid = Array(routeMap.size.row)\n    .fill(null)\n    .map((nouse, i) => {\n      return Array(routeMap.size.col)\n        .fill(null)\n        .map((nouse, j) => {\n          return { isWall: false, isPin: false, netID: -1 };\n        });\n    });\n\n  routeMap.walls.forEach(([i, j]) => {\n    grid[i][j].isWall = true;\n  });\n\n  routeMap.nets.forEach((net) => {\n    net.pins.forEach(([i, j]) => {\n      grid[i][j].isPin = true;\n      grid[i][j].netID = net.netID;\n    });\n  });\n\n  return grid;\n}\n\ntype GridProps = {\n  routeMap: RouteMap;\n  routeResult: RouteResult | undefined;\n};\nexport default function Grid({ routeMap, routeResult }: GridProps) {\n  const [routeMapGrid, setRouteMapGrid] = useState(() =>\n    makeRouteMapGrid(routeMap)\n  );\n  useEffect(() => {\n    setRouteMapGrid(makeRouteMapGrid(routeMap));\n  }, [routeMap]);\n\n  return (\n    <div>\n      {routeMapGrid.map((row, i) => {\n        return (\n          <div key={`grid-row ${i}`} className=\"grid-row\">\n            {row.map((cell, j) => {\n              return (\n                <GridCell\n                  key={`grid-cell ${i} ${j}`}\n                  mapCell={cell}\n                  routeResultCell={routeResult?.grid[i][j]}\n                />\n              );\n            })}\n          </div>\n        );\n      })}\n    </div>\n  );\n}\n\nconst netColors = [\n  \"#ff6347\",\n  \"#adff2f\",\n  \"#4682b4\",\n  \"#F4A460\",\n  \"#dda0dd\",\n\n  \"#6a5acd\",\n  \"#00ff7f\",\n];\n\ntype GridCellProps = {\n  mapCell: RouteMapCellAttr;\n  routeResultCell: RouteResultCell | undefined;\n};\nexport function GridCell({ mapCell, routeResultCell }: GridCellProps) {\n  let color = \"#ccc\";\n  if (mapCell.isWall) {\n    color = \"black\";\n  } else if (mapCell.isPin) {\n    color = netColors[mapCell.netID];\n  }\n\n  if (routeResultCell) {\n    if (routeResultCell.netId !== -1) {\n      color = netColors[routeResultCell.netId];\n    }\n  }\n  return <div className=\"grid-cell\" style={{ backgroundColor: color }}></div>;\n}\n","import { GridSize } from \"./Grid\";\n\nexport enum MapCellType {\n  void = 0,\n  wall,\n  pin,\n}\n\nexport type Coors = [number, number];\nexport interface Net {\n  netID: number;\n  pins: Array<Coors>;\n}\n\nexport interface RouteMap {\n  size: GridSize;\n  walls: Array<Coors>;\n  nets: Array<Net>;\n}\n\nexport function parseRoutingMapString(input: string): RouteMap {\n  const lines = input.split(\"\\n\");\n  const [nCol, nRow] = lines[0].split(\" \").map((a) => parseInt(a));\n  let i_line = 1;\n\n  /// parse obstacles\n  const n_wall = parseInt(lines[i_line++]);\n  const walls = lines.slice(i_line, i_line + n_wall).map((line) => {\n    const [j, i] = line.split(\" \").map((a) => parseInt(a));\n    return [i, j] as Coors;\n  });\n  i_line += n_wall;\n\n  /// parse nets\n  const nets: Array<Net> = [];\n  const n_net = parseInt(lines[i_line++]);\n  lines.slice(i_line, i_line + n_net).forEach((line, netID) => {\n    /// parse pins\n    const [, ...coors] = line\n      .trim()\n      .split(\" \")\n      .map((a) => parseInt(a));\n    const net: Net = { netID: netID, pins: [] };\n    for (let idx = 0; idx < coors.length; idx += 2) {\n      const j = coors[idx],\n        i = coors[idx + 1];\n      net.pins.push([i, j]);\n    }\n    nets.push(net);\n  });\n\n  return {\n    size: { col: nCol, row: nRow },\n    walls: walls,\n    nets: nets,\n  };\n}\n","export interface GridSize {\n  col: number;\n  row: number;\n}\n\nexport class Grid<T> {\n  grid: Array<Array<T>>;\n  size: GridSize;\n\n  constructor(size: GridSize, initializer: (i: number, j: number) => T) {\n    this.size = size;\n    this.grid = Array(size.row)\n      .fill(null)\n      .map((nouse, i) =>\n        Array(size.col)\n          .fill(null)\n          .map((nouse, j) => initializer(i, j))\n      );\n  }\n}\n","import { Grid, GridSize } from \"../Models/Grid\";\nimport { Coors, Net, RouteMap } from \"../Models/RouteMap\";\n\nexport interface Connection {\n  netID: number;\n  segments: Array<Coors>;\n}\n\ninterface ConnectionRoutingResult {\n  succeed: boolean;\n}\n\ninterface ConnectionRoutingSuccess extends ConnectionRoutingResult {\n  connectedPin: Coors;\n  segments: Array<Coors>;\n}\n\nfunction adjacentCoors(i: number, j: number): Array<Coors> {\n  return [\n    [i + 1, j],\n    [i - 1, j],\n    [i, j + 1],\n    [i, j - 1],\n  ];\n}\n\nexport function routeConnection(\n  obstacleGrid: Grid<boolean>,\n  sources: Array<Coors>,\n  targetGrid: Grid<boolean>\n): ConnectionRoutingResult {\n  const { col, row } = obstacleGrid.size;\n  const progressGrid = new Grid<number>(obstacleGrid.size, (i, j) => -1);\n  const inRange = (i: number, j: number) =>\n    i >= 0 && i < row && j >= 0 && j < col;\n  const canExpand = (i: number, j: number) =>\n    inRange(i, j) && !obstacleGrid.grid[i][j] && progressGrid.grid[i][j] === -1;\n\n  /// expansion\n  let expansionList = sources;\n  let iExpand = 0;\n  let connectedTargetCoors: Coors | null = null;\n  while (expansionList.length > 0) {\n    const newExpansionList = [] as Array<Coors>;\n\n    for (const [i, j] of expansionList) {\n      progressGrid.grid[i][j] = iExpand;\n    }\n    for (const [i, j] of expansionList) {\n      for (const [ni, nj] of adjacentCoors(i, j)) {\n        if (canExpand(ni, nj)) {\n          newExpansionList.push([ni, nj]);\n          progressGrid.grid[ni][nj] = -2;\n          /// whether found one of the targets\n          if (targetGrid.grid[ni][nj]) {\n            connectedTargetCoors = [ni, nj];\n          }\n        }\n      }\n    }\n    /// whether found target\n    if (connectedTargetCoors) {\n      expansionList = [];\n    } else {\n      expansionList = newExpansionList;\n      iExpand++;\n    }\n  }\n\n  if (!connectedTargetCoors) {\n    return { succeed: false };\n  }\n\n  /// backtrack\n  const nExpand = iExpand;\n  let [i, j]: Coors = connectedTargetCoors;\n  let iPrevLayer = nExpand;\n  const segments: Array<Coors> = [];\n  while (true) {\n    /* eslint-disable no-loop-func */\n    [i, j] = adjacentCoors(i, j).filter(([ni, nj]) => {\n      return inRange(ni, nj) && progressGrid.grid[ni][nj] === iPrevLayer;\n    })[0];\n    /* eslint-enable no-loop-func */\n\n    if (progressGrid.grid[i][j] === 0) break;\n    segments.push([i, j]);\n    iPrevLayer--;\n  }\n\n  return {\n    succeed: true,\n    segments,\n    connectedPin: connectedTargetCoors,\n  } as ConnectionRoutingSuccess;\n}\n\nfunction makeTargetGrid(size: GridSize, targets: Array<Coors>) {\n  const grid = new Grid(size, (i, j) => {\n    return false;\n  });\n\n  targets.forEach(([i, j]) => {\n    grid.grid[i][j] = true;\n  });\n\n  return grid;\n}\n\nexport interface NetRoutingResult {\n  succeed: boolean;\n}\nexport interface NetRoutingSuccess extends NetRoutingResult {\n  connection: Connection;\n}\nexport function routeNet(\n  obstacleGrid: Grid<boolean>,\n  net: Net\n): NetRoutingResult {\n  const [sourcePin, ...targets] = net.pins;\n  let sources = [sourcePin];\n  const targetGrid = makeTargetGrid(obstacleGrid.size, targets);\n  let nTargets = targets.length;\n\n  while (nTargets > 0) {\n    const result = routeConnection(obstacleGrid, sources, targetGrid);\n    /// fail to route this net if connection route is fail\n    if (!result.succeed) break;\n    const success = result as ConnectionRoutingSuccess;\n\n    /// update sources and targets\n    nTargets -= 1;\n    sources = [...sources, ...success.segments, success.connectedPin];\n    const [ci, cj] = success.connectedPin; // connected pin coor\n    targetGrid.grid[ci][cj] = false;\n  }\n\n  if (nTargets > 0) {\n    return { succeed: false };\n  } else {\n    return {\n      succeed: true,\n      connection: {\n        netID: net.netID,\n        segments: sources,\n      },\n    } as NetRoutingSuccess;\n  }\n}\n\nexport function makeObstacleGrid(\n  routeMap: RouteMap,\n  routingNetID: number,\n  routedConnections: Array<Connection>\n) {\n  const grid = new Grid(routeMap.size, (i, j) => {\n    return false;\n  });\n\n  /// walls are obstacles\n  routeMap.walls.forEach(([i, j]) => {\n    grid.grid[i][j] = true;\n  });\n\n  /// net pins that are not in the routing net are obstacles\n  routeMap.nets\n    .filter((net) => net.netID !== routingNetID)\n    .forEach((net) => {\n      net.pins.forEach(([i, j]) => {\n        grid.grid[i][j] = true;\n      });\n    });\n\n  /// routed connection are obstacles\n  routedConnections.forEach((connection) => {\n    connection.segments.forEach(([i, j]) => {\n      grid.grid[i][j] = true;\n    });\n  });\n\n  return grid;\n}\n\nexport interface MapRouteResult {\n  succeed: boolean;\n}\n\nexport interface MapRouteSuccess extends MapRouteResult {\n  netRouteSequence: Array<Net>;\n  connections: Array<Connection>;\n}\n\nexport interface RouteQueueItem {\n  priority: number;\n  net: Net;\n}\nexport function route(routeMap: RouteMap): MapRouteResult {\n  function tryToRoute(\n    nets: Array<Net>,\n    routedConnections: Array<Connection>\n  ): MapRouteResult {\n    if (nets.length === 0) {\n      return {\n        succeed: true,\n        netRouteSequence: [],\n        connections: [],\n      } as MapRouteSuccess;\n    }\n\n    for (let i = 0; i < nets.length; i++) {\n      const net = nets[i];\n\n      /// try to route the net\n      const obstacleGrid = makeObstacleGrid(routeMap, i, routedConnections);\n      const netResult = routeNet(obstacleGrid, net);\n      if (!netResult.succeed) return { succeed: false };\n      const netSucceed = netResult as NetRoutingSuccess;\n\n      /// if this net can be connected => try route other nets\n      const otherNets = [...nets.slice(0, i), ...nets.slice(i + 1)];\n      const otherNetResult = tryToRoute(otherNets, [\n        ...routedConnections,\n        netSucceed.connection,\n      ]);\n      if (otherNetResult.succeed) {\n        const otherNetSucceed = otherNetResult as MapRouteSuccess;\n        return {\n          succeed: true,\n          netRouteSequence: [net, ...otherNetSucceed.netRouteSequence],\n          connections: [netSucceed.connection, ...otherNetSucceed.connections],\n        } as MapRouteSuccess;\n      }\n    }\n\n    return { succeed: false };\n  }\n\n  return tryToRoute(routeMap.nets, []);\n}\n","import React, { useEffect, useState } from \"react\";\nimport axios from \"axios\";\nimport {\n  AppBar,\n  MenuItem,\n  Select,\n  ThemeProvider,\n  Toolbar,\n} from \"@material-ui/core\";\n\nimport theme from \"./theme\";\nimport \"./App.css\";\nimport Grid from \"./Components/Grid\";\nimport { parseRoutingMapString, RouteMap } from \"./Models/RouteMap\";\nimport { route, MapRouteSuccess } from \"./Routers/Router\";\nimport { Grid as GridModel } from \"./Models/Grid\";\n\nexport interface RouteResultCell {\n  netId: number;\n}\nexport type RouteResult = GridModel<RouteResultCell>;\n\nfunction App() {\n  const [routeResult, setRouteResult] = useState<RouteResult>();\n  const [routeMap, setRouteMap] = useState<RouteMap>();\n\n  useEffect(() => {\n    if (!routeMap) return;\n\n    const routeResult = route(routeMap);\n\n    if (!routeResult.succeed) {\n      setRouteResult(undefined);\n      return;\n    }\n    const succeed = routeResult as MapRouteSuccess;\n    console.log(succeed);\n\n    const grid = new GridModel<RouteResultCell>(routeMap.size, (i, j) => ({\n      netId: -1,\n    }));\n    succeed.connections.forEach((conn) => {\n      conn.segments.forEach(([i, j]) => {\n        grid.grid[i][j].netId = conn.netID;\n      });\n    });\n    setRouteResult(grid);\n  }, [routeMap]);\n\n  function next() {\n    // const grid = new GridModel<RouteResultCell>(routeMap.size, (i, j) => ({\n    //   netId: -1,\n    // }));\n    // grid.grid[0][0].netId = 0;\n    // setRouteResult(grid);\n  }\n\n  const [infiles, setInfiles] = useState<Array<string>>();\n  useEffect(() => {\n    axios.get(\"benchmarks/infiles.json\").then((res) => {\n      setInfiles(res.data);\n    });\n    return () => {};\n  }, []);\n\n  const [mapName, setMapName] = useState(\"impossible.infile\");\n  useEffect(() => {\n    if (mapName === \"\") return;\n    axios.get<string>(`benchmarks/${mapName}`).then((res) => {\n      setRouteMap(parseRoutingMapString(res.data));\n    });\n\n    /// TODO clean up\n  }, [mapName]);\n\n  return (\n    <ThemeProvider theme={theme}>\n      <AppBar position=\"static\">\n        <Toolbar>\n          <Select\n            style={{ width: \"8em\", color: \"white\" }}\n            value={mapName}\n            onChange={(event) => setMapName(event.target.value as string)}\n          >\n            {infiles?.map((filename) => (\n              <MenuItem key={filename} value={filename}>\n                {\" \"}\n                {filename.split(\".\")[0]}{\" \"}\n              </MenuItem>\n            ))}\n          </Select>\n        </Toolbar>\n      </AppBar>\n      <div style={{ margin: 20 }}>\n        {routeMap ? (\n          <Grid routeMap={routeMap} routeResult={routeResult} />\n        ) : (\n          <></>\n        )}\n\n        <button onClick={next}> Next </button>\n      </div>\n    </ThemeProvider>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}