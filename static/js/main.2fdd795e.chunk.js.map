{"version":3,"sources":["theme.ts","Components/NetColorTheme.ts","Components/Grid.tsx","Models/RouteMap.ts","Routers/Router.ts","Models/Grid.ts","Components/RouteProgressItems.tsx","App.tsx","index.tsx"],"names":["theme","createMuiTheme","palette","primary","main","secondary","NetColors","makeRouteMapGrid","routeMap","grid","Array","size","row","fill","map","nouse","i","col","j","isWall","isPin","netID","walls","forEach","nets","net","pins","Grid","routeResult","useState","routeMapGrid","setRouteMapGrid","useEffect","className","cell","GridCell","mapCell","routeResultCell","color","netId","style","backgroundColor","MapCellType","IntermediateRouteResultType","initializer","this","adjacentCoors","routeConnection","obstacleGrid","sources","targetGrid","progressGrid","inRange","canExpand","expansionList","iExpand","connectedTargetCoors","length","newExpansionList","ni","nj","push","succeed","nExpand","iPrevLayer","segments","filter","connectedPin","routeNet","sourcePin","targets","makeTargetGrid","nTargets","result","success","ci","cj","connection","makeObstacleGrid","routingNetID","routedConnections","ConnectSucceed","id","uuidv4","connectionHistory","conn","newConnection","ConnectFailNet","failedNet","ConnectFailAll","circuitDrawerWidth","makeRouteResultGridFromConnections","connections","GridModel","useStyles","makeStyles","createStyles","root","display","appBar","width","left","circuitDrawer","flexShrink","circuitDrawerPaper","historyDrawer","historyDrawerPaper","toolbar","mixins","content","flexGrow","background","default","padding","spacing","App","setRouteResult","setRouteMap","classes","infiles","setInfiles","axios","get","then","res","data","mapName","setMapName","input","lines","split","a","parseInt","nCol","nRow","i_line","n_wall","slice","line","n_net","trim","coors","idx","parseRoutingMapString","routingMapList","List","filename","ListItem","button","onClick","selected","routeHistory","setRouteHistory","innerResultCallback","prev","yieldResultCallback","tryToRoute","netRouteSequence","netResult","netSucceed","type","Succeed","otherNetResult","otherNetSucceed","FailNet","FailAll","route","console","log","undefined","routingHistory","succeedResult","Box","fontSize","ErrorOutline","CssBaseline","ThemeProvider","AppBar","position","Toolbar","Typography","variant","noWrap","Drawer","open","paper","anchor","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.2fdd795e.chunk.js","sourcesContent":["import { unstable_createMuiStrictModeTheme as createMuiTheme } from \"@material-ui/core\";\n\nconst theme = createMuiTheme({\n  palette: {\n    primary: {\n      main: \"#203040\",\n    },\n    secondary: {\n      main: \"#abc\",\n    },\n  },\n});\n\nexport default theme;\n","const NetColors = [\n  \"#ff6347\",\n  \"#92da26\", // adff2f\n  \"#4682b4\",\n  \"#F4A460\",\n  \"#dda0dd\",\n\n  \"#6a5acd\",\n  \"#00ff7f\",\n];\n\nexport default NetColors;\n","import { useState, useEffect } from \"react\";\nimport { RouteResult, RouteResultCell } from \"../App\";\nimport { RouteMap } from \"../Models/RouteMap\";\nimport \"./Grid.css\";\nimport NetColors from \"./NetColorTheme\";\n\nexport class RouteMapCellAttr {\n  isWall = false;\n  isPin = false;\n  netID = -1;\n}\n\nfunction makeRouteMapGrid(routeMap: RouteMap): Array<Array<RouteMapCellAttr>> {\n  const grid = Array(routeMap.size.row)\n    .fill(null)\n    .map((nouse, i) => {\n      return Array(routeMap.size.col)\n        .fill(null)\n        .map((nouse, j) => {\n          return { isWall: false, isPin: false, netID: -1 };\n        });\n    });\n\n  routeMap.walls.forEach(([i, j]) => {\n    grid[i][j].isWall = true;\n  });\n\n  routeMap.nets.forEach((net) => {\n    net.pins.forEach(([i, j]) => {\n      grid[i][j].isPin = true;\n      grid[i][j].netID = net.netID;\n    });\n  });\n\n  return grid;\n}\n\ntype GridProps = {\n  routeMap: RouteMap;\n  routeResult: RouteResult | undefined;\n};\nexport default function Grid({ routeMap, routeResult }: GridProps) {\n  const [routeMapGrid, setRouteMapGrid] = useState(() =>\n    makeRouteMapGrid(routeMap)\n  );\n  useEffect(() => {\n    setRouteMapGrid(makeRouteMapGrid(routeMap));\n  }, [routeMap]);\n\n  return (\n    <div>\n      {routeMapGrid.map((row, i) => {\n        return (\n          <div key={`grid-row ${i}`} className=\"grid-row\">\n            {row.map((cell, j) => {\n              return (\n                <GridCell\n                  key={`grid-cell ${i} ${j}`}\n                  mapCell={cell}\n                  routeResultCell={routeResult?.grid[i][j]}\n                />\n              );\n            })}\n          </div>\n        );\n      })}\n    </div>\n  );\n}\n\ntype GridCellProps = {\n  mapCell: RouteMapCellAttr;\n  routeResultCell: RouteResultCell | undefined;\n};\nexport function GridCell({ mapCell, routeResultCell }: GridCellProps) {\n  let color = \"#ccc\";\n  if (mapCell.isWall) {\n    color = \"black\";\n  } else if (mapCell.isPin) {\n    color = NetColors[mapCell.netID];\n  }\n\n  if (routeResultCell) {\n    if (routeResultCell.netId !== -1) {\n      color = NetColors[routeResultCell.netId];\n    }\n  }\n  return (\n    <div className=\"grid-cell\" style={{ backgroundColor: color }}>\n      <div className={mapCell.isPin ? \"pin\" : \"\"} />\n    </div>\n  );\n}\n","import { GridSize } from \"./Grid\";\n\nexport enum MapCellType {\n  void = 0,\n  wall,\n  pin,\n}\n\nexport type Coors = [number, number];\nexport interface Net {\n  netID: number;\n  pins: Array<Coors>;\n}\n\nexport interface RouteMap {\n  size: GridSize;\n  walls: Array<Coors>;\n  nets: Array<Net>;\n}\n\nexport function parseRoutingMapString(input: string): RouteMap {\n  const lines = input.split(\"\\n\");\n  const [nCol, nRow] = lines[0].split(\" \").map((a) => parseInt(a));\n  let i_line = 1;\n\n  /// parse obstacles\n  const n_wall = parseInt(lines[i_line++]);\n  const walls = lines.slice(i_line, i_line + n_wall).map((line) => {\n    const [j, i] = line.split(\" \").map((a) => parseInt(a));\n    return [i, j] as Coors;\n  });\n  i_line += n_wall;\n\n  /// parse nets\n  const nets: Array<Net> = [];\n  const n_net = parseInt(lines[i_line++]);\n  lines.slice(i_line, i_line + n_net).forEach((line, netID) => {\n    /// parse pins\n    const [, ...coors] = line\n      .trim()\n      .split(\" \")\n      .map((a) => parseInt(a));\n    const net: Net = { netID: netID, pins: [] };\n    for (let idx = 0; idx < coors.length; idx += 2) {\n      const j = coors[idx],\n        i = coors[idx + 1];\n      net.pins.push([i, j]);\n    }\n    nets.push(net);\n  });\n\n  return {\n    size: { col: nCol, row: nRow },\n    walls: walls,\n    nets: nets,\n  };\n}\n","import { Grid, GridSize } from \"../Models/Grid\";\nimport { Coors, Net, RouteMap } from \"../Models/RouteMap\";\n\nexport interface Connection {\n  netID: number;\n  segments: Array<Coors>;\n}\n\ninterface ConnectionRoutingResult {\n  succeed: boolean;\n}\n\ninterface ConnectionRoutingSuccess extends ConnectionRoutingResult {\n  connectedPin: Coors;\n  segments: Array<Coors>;\n}\n\nfunction adjacentCoors(i: number, j: number): Array<Coors> {\n  return [\n    [i + 1, j],\n    [i - 1, j],\n    [i, j + 1],\n    [i, j - 1],\n  ];\n}\n\nexport function routeConnection(\n  obstacleGrid: Grid<boolean>,\n  sources: Array<Coors>,\n  targetGrid: Grid<boolean>\n): ConnectionRoutingResult {\n  const { col, row } = obstacleGrid.size;\n  const progressGrid = new Grid<number>(obstacleGrid.size, (i, j) => -1);\n  const inRange = (i: number, j: number) =>\n    i >= 0 && i < row && j >= 0 && j < col;\n  const canExpand = (i: number, j: number) =>\n    inRange(i, j) && !obstacleGrid.grid[i][j] && progressGrid.grid[i][j] === -1;\n\n  /// expansion\n  let expansionList = sources;\n  let iExpand = 0;\n  let connectedTargetCoors: Coors | null = null;\n  while (expansionList.length > 0) {\n    const newExpansionList = [] as Array<Coors>;\n\n    for (const [i, j] of expansionList) {\n      progressGrid.grid[i][j] = iExpand;\n    }\n    for (const [i, j] of expansionList) {\n      for (const [ni, nj] of adjacentCoors(i, j)) {\n        if (canExpand(ni, nj)) {\n          newExpansionList.push([ni, nj]);\n          progressGrid.grid[ni][nj] = -2;\n          /// whether found one of the targets\n          if (targetGrid.grid[ni][nj]) {\n            connectedTargetCoors = [ni, nj];\n          }\n        }\n      }\n    }\n    /// whether found target\n    if (connectedTargetCoors) {\n      expansionList = [];\n    } else {\n      expansionList = newExpansionList;\n      iExpand++;\n    }\n  }\n\n  if (!connectedTargetCoors) {\n    return { succeed: false };\n  }\n\n  /// backtrack\n  const nExpand = iExpand;\n  let [i, j]: Coors = connectedTargetCoors;\n  let iPrevLayer = nExpand;\n  const segments: Array<Coors> = [];\n  while (true) {\n    /* eslint-disable no-loop-func */\n    [i, j] = adjacentCoors(i, j).filter(([ni, nj]) => {\n      return inRange(ni, nj) && progressGrid.grid[ni][nj] === iPrevLayer;\n    })[0];\n    /* eslint-enable no-loop-func */\n\n    if (progressGrid.grid[i][j] === 0) break;\n    segments.push([i, j]);\n    iPrevLayer--;\n  }\n\n  return {\n    succeed: true,\n    segments,\n    connectedPin: connectedTargetCoors,\n  } as ConnectionRoutingSuccess;\n}\n\nfunction makeTargetGrid(size: GridSize, targets: Array<Coors>) {\n  const grid = new Grid(size, (i, j) => {\n    return false;\n  });\n\n  targets.forEach(([i, j]) => {\n    grid.grid[i][j] = true;\n  });\n\n  return grid;\n}\n\nexport interface NetRoutingResult {\n  succeed: boolean;\n}\nexport interface NetRoutingSuccess extends NetRoutingResult {\n  connection: Connection;\n}\nexport function routeNet(\n  obstacleGrid: Grid<boolean>,\n  net: Net\n): NetRoutingResult {\n  const [sourcePin, ...targets] = net.pins;\n  let sources = [sourcePin];\n  const targetGrid = makeTargetGrid(obstacleGrid.size, targets);\n  let nTargets = targets.length;\n\n  while (nTargets > 0) {\n    const result = routeConnection(obstacleGrid, sources, targetGrid);\n    /// fail to route this net if connection route is fail\n    if (!result.succeed) break;\n    const success = result as ConnectionRoutingSuccess;\n\n    /// update sources and targets\n    nTargets -= 1;\n    sources = [...sources, ...success.segments, success.connectedPin];\n    const [ci, cj] = success.connectedPin; // connected pin coor\n    targetGrid.grid[ci][cj] = false;\n  }\n\n  if (nTargets > 0) {\n    return { succeed: false };\n  } else {\n    return {\n      succeed: true,\n      connection: {\n        netID: net.netID,\n        segments: sources,\n      },\n    } as NetRoutingSuccess;\n  }\n}\n\nexport function makeObstacleGrid(\n  routeMap: RouteMap,\n  routingNetID: number,\n  routedConnections: Array<Connection>\n) {\n  const grid = new Grid(routeMap.size, (i, j) => {\n    return false;\n  });\n\n  /// walls are obstacles\n  routeMap.walls.forEach(([i, j]) => {\n    grid.grid[i][j] = true;\n  });\n\n  /// net pins that are not in the routing net are obstacles\n  routeMap.nets\n    .filter((net) => net.netID !== routingNetID)\n    .forEach((net) => {\n      net.pins.forEach(([i, j]) => {\n        grid.grid[i][j] = true;\n      });\n    });\n\n  /// routed connection are obstacles\n  routedConnections.forEach((connection) => {\n    connection.segments.forEach(([i, j]) => {\n      grid.grid[i][j] = true;\n    });\n  });\n\n  return grid;\n}\n\nexport interface MapRouteResult {\n  succeed: boolean;\n}\n\nexport interface MapRouteSuccess extends MapRouteResult {\n  netRouteSequence: Array<Net>;\n  connections: Array<Connection>;\n}\n\nexport interface RouteQueueItem {\n  priority: number;\n  net: Net;\n}\n\nexport interface IntermediateRouteSucceed extends IntermediateRouteResult {\n  connectionHistory: Array<Connection>;\n  newConnection: Connection;\n}\n\nexport interface IntermediateRouteFailNet extends IntermediateRouteResult {\n  connectionHistory: Array<Connection>;\n  failedNet: Net;\n}\n\nexport interface IntermediateRouteFailAll extends IntermediateRouteResult {\n  connectionHistory: Array<Connection>;\n}\n\nexport enum IntermediateRouteResultType {\n  Succeed = 0,\n  FailNet,\n  FailAll,\n}\n\nexport interface IntermediateRouteResult {\n  type: IntermediateRouteResultType;\n}\n\nexport function route(\n  routeMap: RouteMap,\n  yieldResultCallback: (arg0: IntermediateRouteResult) => void\n): MapRouteResult {\n  function tryToRoute(\n    nets: Array<Net>,\n    routedConnections: Array<Connection>\n  ): MapRouteResult {\n    if (nets.length === 0) {\n      return {\n        succeed: true,\n        netRouteSequence: [],\n        connections: [],\n      } as MapRouteSuccess;\n    }\n\n    for (let i = 0; i < nets.length; i++) {\n      const net = nets[i];\n\n      /// try to route the net\n      const obstacleGrid = makeObstacleGrid(routeMap, i, routedConnections);\n      const netResult = routeNet(obstacleGrid, net);\n      if (!netResult.succeed) {\n        yieldResultCallback({\n          type: IntermediateRouteResultType.FailNet,\n          connectionHistory: routedConnections,\n          failedNet: net,\n        } as IntermediateRouteFailNet);\n        continue;\n      }\n      const netSucceed = netResult as NetRoutingSuccess;\n      yieldResultCallback({\n        type: IntermediateRouteResultType.Succeed,\n        connectionHistory: routedConnections,\n        newConnection: netSucceed.connection,\n      } as IntermediateRouteSucceed);\n\n      /// if this net can be connected => try route other nets\n      const otherNets = [...nets.slice(0, i), ...nets.slice(i + 1)];\n      const otherNetResult = tryToRoute(otherNets, [\n        ...routedConnections,\n        netSucceed.connection,\n      ]);\n      if (otherNetResult.succeed) {\n        const otherNetSucceed = otherNetResult as MapRouteSuccess;\n        return {\n          succeed: true,\n          netRouteSequence: [net, ...otherNetSucceed.netRouteSequence],\n          connections: [netSucceed.connection, ...otherNetSucceed.connections],\n        } as MapRouteSuccess;\n      }\n    }\n\n    yieldResultCallback({\n      type: IntermediateRouteResultType.FailAll,\n      connectionHistory: routedConnections,\n    } as IntermediateRouteFailAll);\n    return { succeed: false };\n  }\n\n  return tryToRoute(routeMap.nets, []);\n}\n","export interface GridSize {\n  col: number;\n  row: number;\n}\n\nexport class Grid<T> {\n  grid: Array<Array<T>>;\n  size: GridSize;\n\n  constructor(size: GridSize, initializer: (i: number, j: number) => T) {\n    this.size = size;\n    this.grid = Array(size.row)\n      .fill(null)\n      .map((nouse, i) =>\n        Array(size.col)\n          .fill(null)\n          .map((nouse, j) => initializer(i, j))\n      );\n  }\n}\n","import React from \"react\";\nimport {\n  IntermediateRouteFailAll,\n  IntermediateRouteFailNet,\n  IntermediateRouteSucceed,\n} from \"../Routers/Router\";\nimport NetColors from \"./NetColorTheme\";\nimport \"./RouteProgressItems.css\";\nimport { v4 as uuidv4 } from \"uuid\";\n\ntype ConnectedSucceedProps = {\n  result: IntermediateRouteSucceed;\n};\nexport function ConnectSucceed({ result }: ConnectedSucceedProps) {\n  const id = uuidv4();\n  return (\n    <div>\n      <div className=\"history-list\">\n        {result.connectionHistory.map((conn, i) => {\n          return (\n            <div\n              key={`${id} ${i}`}\n              className=\"history-cell\"\n              style={{ backgroundColor: NetColors[conn.netID] }}\n            ></div>\n          );\n        })}\n        <div\n          className=\"history-cell\"\n          style={{ backgroundColor: NetColors[result.newConnection.netID] }}\n        ></div>\n      </div>\n    </div>\n  );\n}\n\ntype ConnectFailNetProps = {\n  result: IntermediateRouteFailNet;\n};\nexport function ConnectFailNet({ result }: ConnectFailNetProps) {\n  const id = uuidv4();\n  return (\n    <div>\n      <div className=\"history-list\">\n        {result.connectionHistory.map((conn, i) => {\n          return (\n            <div\n              key={`${id} ${i}`}\n              className=\"history-cell\"\n              style={{ backgroundColor: NetColors[conn.netID] }}\n            ></div>\n          );\n        })}\n        <div\n          className=\"history-cell\"\n          style={{ backgroundColor: NetColors[result.failedNet.netID] }}\n        ></div>\n      </div>\n    </div>\n  );\n}\n\ntype ConnectFailAllProps = {\n  result: IntermediateRouteFailAll;\n};\nexport function ConnectFailAll({ result }: ConnectFailAllProps) {\n  const id = uuidv4();\n  return (\n    <div>\n      <div className=\"history-list\">\n        {result.connectionHistory.map((conn, i) => {\n          return (\n            <div\n              key={`${id} ${i}`}\n              className=\"history-cell\"\n              style={{ backgroundColor: NetColors[conn.netID] }}\n            ></div>\n          );\n        })}\n      </div>\n    </div>\n  );\n}\n","import React, { useEffect, useState } from \"react\";\nimport axios from \"axios\";\nimport {\n  AppBar,\n  Box,\n  Container,\n  createStyles,\n  CssBaseline,\n  Divider,\n  Drawer,\n  List,\n  ListItem,\n  makeStyles,\n  MenuItem,\n  Select,\n  Theme,\n  ThemeProvider,\n  Toolbar,\n  Typography,\n} from \"@material-ui/core\";\n\nimport theme from \"./theme\";\nimport \"./App.css\";\nimport Grid from \"./Components/Grid\";\nimport { parseRoutingMapString, RouteMap } from \"./Models/RouteMap\";\nimport {\n  route,\n  MapRouteSuccess,\n  IntermediateRouteResultType,\n  IntermediateRouteResult,\n  IntermediateRouteSucceed,\n  IntermediateRouteFailNet,\n  IntermediateRouteFailAll,\n  Connection,\n} from \"./Routers/Router\";\nimport { Grid as GridModel, GridSize } from \"./Models/Grid\";\nimport {\n  ConnectSucceed,\n  ConnectFailAll,\n  ConnectFailNet,\n} from \"./Components/RouteProgressItems\";\n\nimport {\n  CheckCircle as CheckIcon,\n  ErrorOutline as ErrorOutlineIcon,\n  RemoveCircle as BannedIcon,\n} from \"@material-ui/icons\";\n\nexport interface RouteResultCell {\n  netId: number;\n}\nexport type RouteResult = GridModel<RouteResultCell>;\n\nconst circuitDrawerWidth = 150;\nconst historyDrawerWidth = 150;\n\nfunction makeRouteResultGridFromConnections(\n  size: GridSize,\n  connections: Array<Connection>\n) {\n  const grid = new GridModel<RouteResultCell>(size, (i, j) => ({\n    netId: -1,\n  }));\n  connections.forEach((conn) => {\n    conn.segments.forEach(([i, j]) => {\n      grid.grid[i][j].netId = conn.netID;\n    });\n  });\n  return grid;\n}\n\nconst useStyles = makeStyles((theme: Theme) =>\n  createStyles({\n    root: {\n      display: \"flex\",\n    },\n    appBar: {\n      width: `calc(100% - ${circuitDrawerWidth}px - ${historyDrawerWidth}px)`,\n      left: circuitDrawerWidth,\n    },\n    circuitDrawer: {\n      width: circuitDrawerWidth,\n      flexShrink: 0,\n    },\n    circuitDrawerPaper: {\n      width: circuitDrawerWidth,\n    },\n    historyDrawer: {\n      width: historyDrawerWidth,\n    },\n    historyDrawerPaper: {\n      width: historyDrawerWidth,\n      flexShrink: 0,\n    },\n    // necessary for content to be below app bar\n    toolbar: theme.mixins.toolbar,\n    content: {\n      flexGrow: 1,\n      backgroundColor: theme.palette.background.default,\n      padding: theme.spacing(3),\n    },\n  })\n);\n\nfunction App() {\n  const [routeResult, setRouteResult] = useState<RouteResult>();\n  const [routeMap, setRouteMap] = useState<RouteMap>();\n  const classes = useStyles();\n\n  function next() {\n    // const grid = new GridModel<RouteResultCell>(routeMap.size, (i, j) => ({\n    //   netId: -1,\n    // }));\n    // grid.grid[0][0].netId = 0;\n    // setRouteResult(grid);\n  }\n\n  const [infiles, setInfiles] = useState<Array<string>>();\n  useEffect(() => {\n    axios.get(\"benchmarks/infiles.json\").then((res) => {\n      setInfiles(res.data);\n    });\n    return () => {};\n  }, []);\n\n  const [mapName, setMapName] = useState(\"impossible.infile\");\n  useEffect(() => {\n    if (mapName === \"\") return;\n    axios.get<string>(`benchmarks/${mapName}`).then((res) => {\n      setRouteMap(parseRoutingMapString(res.data));\n    });\n\n    /// TODO clean up\n  }, [mapName]);\n\n  const routingMapList = (\n    <List>\n      {infiles?.map((filename) => (\n        <ListItem\n          button\n          key={filename}\n          onClick={() => setMapName(filename)}\n          selected={filename === mapName}\n        >\n          {filename.split(\".\")[0]}\n        </ListItem>\n      ))}\n    </List>\n  );\n\n  const [routeHistory, setRouteHistory] = useState(\n    [] as Array<IntermediateRouteResult>\n  );\n\n  const innerResultCallback = (result: IntermediateRouteResult) => {\n    setRouteHistory((prev) => {\n      if (prev.length > 100) return prev;\n      return [...prev, result];\n    });\n  };\n\n  useEffect(() => {\n    if (!routeMap) return;\n\n    setRouteHistory([]);\n    const routeResult = route(routeMap, innerResultCallback);\n\n    if (!routeResult.succeed) {\n      setRouteResult(undefined);\n      return;\n    }\n    const succeed = routeResult as MapRouteSuccess;\n    console.log(succeed);\n\n    const grid = makeRouteResultGridFromConnections(\n      routeMap.size,\n      succeed.connections\n    );\n    setRouteResult(grid);\n  }, [routeMap]);\n\n  const routingHistory = (\n    <List>\n      {routeHistory.map((result, i) => {\n        switch (result.type) {\n          case IntermediateRouteResultType.Succeed:\n            const succeedResult = result as IntermediateRouteSucceed;\n            return (\n              <ListItem\n                button\n                key={`history ${i}`}\n                onClick={() => {\n                  if (!routeMap) return;\n                  const grid = makeRouteResultGridFromConnections(\n                    routeMap.size,\n                    [\n                      ...succeedResult.connectionHistory,\n                      succeedResult.newConnection,\n                    ]\n                  );\n                  setRouteResult(grid);\n                }}\n              >\n                <Box color=\"success.main\" className=\"icon-alignment\">\n                  <CheckIcon fontSize=\"small\" />\n                </Box>\n                <ConnectSucceed\n                  result={result as IntermediateRouteSucceed}\n                ></ConnectSucceed>\n              </ListItem>\n            );\n          case IntermediateRouteResultType.FailNet:\n            return (\n              <ListItem button key={`history ${i}`}>\n                <Box color=\"error.main\" className=\"icon-alignment\">\n                  <ErrorOutlineIcon fontSize=\"small\" />\n                </Box>\n                <ConnectFailNet\n                  result={result as IntermediateRouteFailNet}\n                ></ConnectFailNet>\n              </ListItem>\n            );\n          case IntermediateRouteResultType.FailAll:\n            return (\n              <ListItem button key={`history ${i}`}>\n                <Box color=\"error.main\" className=\"icon-alignment\">\n                  <BannedIcon fontSize=\"small\" />\n                </Box>\n                <ConnectFailAll\n                  result={result as IntermediateRouteFailAll}\n                ></ConnectFailAll>\n              </ListItem>\n            );\n          default:\n            return \"0\";\n        }\n      })}\n    </List>\n  );\n\n  return (\n    <div className={classes.root}>\n      <CssBaseline />\n      <ThemeProvider theme={theme}>\n        <AppBar position=\"fixed\" className={classes.appBar}>\n          <Toolbar>\n            {\" \"}\n            <Typography variant=\"h6\" noWrap>\n              {mapName}\n            </Typography>\n          </Toolbar>\n        </AppBar>\n        <Drawer\n          open={true}\n          variant=\"permanent\"\n          className={classes.circuitDrawer}\n          classes={{ paper: classes.circuitDrawerPaper }}\n        >\n          {routingMapList}\n        </Drawer>\n        <main className={classes.content}>\n          <div className={classes.toolbar} />\n          {routeMap ? (\n            <Grid routeMap={routeMap} routeResult={routeResult} />\n          ) : (\n            <></>\n          )}\n        </main>\n        <Drawer\n          open={true}\n          variant=\"permanent\"\n          className={classes.historyDrawer}\n          classes={{ paper: classes.historyDrawerPaper }}\n          anchor=\"right\"\n        >\n          {routingHistory}\n        </Drawer>\n      </ThemeProvider>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}